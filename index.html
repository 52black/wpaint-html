<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>绘制页面</title>
<style>
html,body { height: 100%; }
body { margin: 0; background: #000; display: grid; place-items: center; overflow: hidden; }
.stage, .container, .canvas, .sidebar, .tool-btn, .palette-panel, .pattern-picker { -webkit-user-select: none; user-select: none; -webkit-touch-callout: none; }
.tool-btn, .canvas { -webkit-tap-highlight-color: transparent; }
.stage { position: relative; }
.stage .container { transform-origin: top left; }
.container { width: 512px; height: 342px; position: relative; background: #fff; overflow: hidden; }
.canvas-viewport { position: absolute; top: 0; left: 0; width: 360px; height: 342px; border: 1px solid #ccc; background: transparent; z-index: 2; overflow: hidden; touch-action: none; }
.canvas-bg { position: absolute; top: 0; left: 0; width: 360px; height: 342px; z-index: 1; }
.canvas { position: absolute; top: 0; left: 0; width: 360px; height: 342px; border: none; background: transparent; z-index: 2; touch-action: none; }
.tool-btn { position: absolute; z-index: 2; padding: 6px 10px; border: 1px solid rgba(0,0,0,.15); border-radius: 10px; background: rgba(255,255,255,.92); color: #111; cursor: pointer; box-shadow: 0 2px 10px rgba(0,0,0,.08); backdrop-filter: blur(6px); }
.tool-btn:hover { background: rgba(255,255,255,.98); }
.tool-btn:active { transform: translateY(1px); }
.tool-btn.is-active { background: rgba(17,17,17,.92); color: #fff; border-color: rgba(0,0,0,.25); }
.tool-btn.is-active:hover { background: rgba(17,17,17,.98); }
.sidebar { position: absolute; top: 8px; right: 8px; width: 136px; height: calc(100% - 16px); z-index: 6; display: flex; flex-direction: column; gap: 8px; align-items: stretch; }
.toolbar-right { display: flex; flex-direction: column; gap: 6px; align-items: stretch; }
.toolbar-left { display: flex; flex-direction: column; gap: 6px; align-items: stretch; }
.toolbar-row { display: flex; gap: 6px; justify-content: flex-end; align-items: center; }
.toolbar-right .tool-btn, .toolbar-left .tool-btn { position: static; }
.toolbar-left .pattern-picker, .toolbar-left .palette-panel { position: static; }
.tool-btn.tool-icon { width: 40px; height: 32px; padding: 0; display: grid; place-items: center; }
.tool-btn.tool-icon svg { width: 18px; height: 18px; display: block; }
.tool-btn.has-icon { display: inline-flex; align-items: center; gap: 6px; }
.file-menu-wrap { position: relative; z-index: 60; }
.file-menu { position: absolute; right: 0; top: calc(100% + 6px); min-width: 152px; padding: 8px; border: 1px solid rgba(0,0,0,.12); border-radius: 12px; background: rgba(255,255,255,.96); box-shadow: 0 10px 28px rgba(0,0,0,.16); display: none; box-sizing: border-box; z-index: 70; }
.file-menu.is-open { display: block; }
.file-menu .tool-btn { width: 100%; box-shadow: none; }
.file-menu .tool-btn + .tool-btn { margin-top: 6px; }
.tool-pen { top: 8px; right: 8px; }
.tool-pen2 { top: 38px; right: 8px; }
.tool-clear { top: 68px; right: 8px; }
.tool-undo { top: 98px; right: 8px; }
.tool-redo { top: 128px; right: 8px; }
.tool-export { top: 158px; right: 8px; }
.tool-importgif { top: 188px; right: 8px; }
.tool-importbg { top: 218px; right: 8px; }
.tool-advanced { top: 248px; right: 8px; }
.tool-eraser { bottom: 8px; right: 8px; }
.tool-color { bottom: 8px; left: 8px; }
.tool-btn svg { width: 18px; height: 18px; display: block; }
.tool-btn .btn-icon { display: inline-flex; align-items: center; justify-content: center; }
.tool-btn.tool-pen, .tool-btn.tool-pen2, .tool-btn.tool-eraser { width: 40px; height: 32px; padding: 0; display: grid; place-items: center; }
.sidebar-footer { margin-top: auto; display: flex; gap: 2px; justify-content: flex-end; align-items: center; flex-wrap: nowrap; }
.sidebar-footer .action-btn { width: 30px; height: 30px; padding: 0; display: grid; place-items: center; }
.sidebar-footer .action-btn svg { width: 16px; height: 16px; display: block; }
.zoom-menu-wrap { position: relative; }
.zoom-menu { position: absolute; right: 0; bottom: calc(100% + 6px); width: 220px; padding: 10px; border: 1px solid rgba(0,0,0,.12); border-radius: 12px; background: rgba(255,255,255,.96); box-shadow: 0 10px 28px rgba(0,0,0,.16); display: none; box-sizing: border-box; z-index: 80; }
.zoom-menu.is-open { display: block; }
.zoom-menu .row { display: flex; align-items: center; gap: 8px; justify-content: space-between; }
.zoom-menu .row + .row { margin-top: 8px; }
.zoom-menu .zoom-controls { display: flex; align-items: center; gap: 8px; flex: 1; }
.zoom-menu .zoom-controls input[type="range"] { width: 100%; accent-color: #111; }
.zoom-menu .zoom-icon-btn { width: 30px; height: 30px; padding: 0; display: grid; place-items: center; box-shadow: none; }
.zoom-menu .zoom-icon-btn svg { width: 16px; height: 16px; }
.zoom-menu .pill { background: rgba(17,17,17,.92); color: #fff; }
.canvas, .checkerboard, .canvas-bg { transform-origin: top left; }
.action-btn:disabled { opacity: .6; cursor: not-allowed; }
.modal-overlay { position: absolute; inset: 0; z-index: 80; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,.35); padding: 16px; box-sizing: border-box; }
.modal-overlay.is-open { display: flex; }
.modal-card { width: min(360px,100%); border: 1px solid rgba(0,0,0,.12); border-radius: 14px; background: rgba(255,255,255,.98); box-shadow: 0 18px 50px rgba(0,0,0,.22); padding: 12px; box-sizing: border-box; position: relative; }
.modal-card.is-draggable { position: absolute; }
.modal-card.anim-card { width: min(320px,100%); }
.modal-head { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 10px; cursor: grab; user-select: none; }
.modal-head:active { cursor: grabbing; }
.modal-body { display: grid; gap: 6px; font-size: 13px; line-height: 1.4; }
.anim-bar { display: flex; align-items: center; justify-content: flex-start; gap: 10px; margin-bottom: 8px; }
.anim-frames { display: flex; flex-wrap: wrap; gap: 6px; padding: 6px; border: 1px solid rgba(0,0,0,.10); border-radius: 12px; background: rgba(255,255,255,.75); touch-action: none; }
.anim-frame-btn { width: 34px; height: 28px; border-radius: 10px; border: 1px solid rgba(0,0,0,.15); background: rgba(255,255,255,.92); cursor: pointer; touch-action: none; }
.anim-frame-btn.is-active { background: rgba(17,17,17,.92); color: #fff; border-color: rgba(17,17,17,.92); }
.anim-frame-btn.is-selected { box-shadow: 0 0 0 2px rgba(0,0,0,.75) inset; }
.anim-frame-btn.is-dragging { opacity: .75; }
.anim-frame-placeholder { width: 34px; height: 28px; border-radius: 10px; border: 2px dashed rgba(0,0,0,.45); box-sizing: border-box; background: rgba(0,0,0,.02); }
.anim-row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
.anim-row input[type="number"] { width: 96px; height: 28px; border-radius: 10px; border: 1px solid rgba(0,0,0,.12); padding: 0 8px; }
.overlay { position: absolute; inset: 0; background: rgba(245,245,245,.96); display: none; flex-direction: column; padding: 12px; box-sizing: border-box; z-index: 3; }
.container.color-mode .tool-btn { display: none; }
.container.color-mode .sidebar { display: none; }
.container.color-mode .jitter-panel { display: none !important; }
.container.color-mode .canvas { display: none; }
.container.color-mode .checkerboard { display: none; }
.container.color-mode .palette-panel { display: none; }
.jitter-panel { position: absolute; top: 8px; left: 8px; z-index: 4; display: none; grid-template-rows: auto auto; gap: 8px; padding: 8px 10px; border: 1px solid rgba(0,0,0,.12); border-radius: 12px; background: rgba(255,255,255,.86); font-size: 12px; }
.container.advanced .jitter-panel { display: grid; }
.jitter-panel .row { display: flex; align-items: center; gap: 8px; }
.jitter-panel .label { opacity: .8; }
.jitter-panel input[type="range"] { accent-color: #111; }
.jitter-panel input:disabled { opacity: .5; }
.jitter-panel input[type="number"] { width: 62px; height: 28px; border-radius: 10px; border: 1px solid rgba(0,0,0,.12); padding: 0 8px; background: rgba(255,255,255,.9); }
.jitter-panel select { height: 28px; border-radius: 10px; border: 1px solid rgba(0,0,0,.12); background: rgba(255,255,255,.9); padding: 0 8px; }
.toggle { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(0,0,0,.10); background: rgba(255,255,255,.85); user-select: none; }
.toggle input[type="checkbox"] { width: 34px; height: 18px; appearance: none; -webkit-appearance: none; border-radius: 999px; background: rgba(0,0,0,.15); position: relative; outline: none; cursor: pointer; transition: background .15s ease; }
.toggle input[type="checkbox"]::after { content: ""; position: absolute; top: 2px; left: 2px; width: 14px; height: 14px; border-radius: 999px; background: #fff; box-shadow: 0 2px 6px rgba(0,0,0,.25); transition: transform .15s ease; }
.toggle input[type="checkbox"]:checked { background: rgba(17,17,17,.9); }
.toggle input[type="checkbox"]:checked::after { transform: translateX(16px); }
.toggle span { line-height: 1; }
.range { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(0,0,0,.10); background: rgba(255,255,255,.85); }
.range input[type="range"] { width: 140px; accent-color: #111; }
.pill { min-width: 22px; text-align: center; padding: 2px 8px; border-radius: 999px; background: rgba(17,17,17,.92); color: #fff; font-variant-numeric: tabular-nums; }
.action-btn { padding: 6px 10px; border: 1px solid rgba(0,0,0,.15); border-radius: 10px; background: rgba(255,255,255,.92); color: #111; cursor: pointer; box-shadow: 0 2px 10px rgba(0,0,0,.08); }
.action-btn:hover { background: rgba(255,255,255,.98); }
.action-btn:active { transform: translateY(1px); }
.action-btn.is-active { background: rgba(17,17,17,.92); color: #fff; border-color: rgba(17,17,17,.92); }
.checkerboard { position: absolute; top: 0; left: 0; width: 360px; height: 342px; z-index: 1; display: none;
  background-size: 16px 16px;
  background-position: 0 0, 8px 8px;
}
.palette-panel { z-index: 2; display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; width: 136px; }
.pattern-picker { z-index: 3; position: relative; width: 136px; }
.container.color-mode .pattern-picker { display: none; }
.pattern-select { width: 100%; display: inline-flex; align-items: center; justify-content: center; gap: 8px; height: 28px; border-radius: 10px; border: 1px solid rgba(0,0,0,.15); background: rgba(255,255,255,.92); padding: 0 10px; cursor: pointer; box-shadow: 0 2px 10px rgba(0,0,0,.08); }
.pattern-select:active { transform: translateY(1px); }
.pattern-select .thumb { width: 18px; height: 18px; border-radius: 6px; border: 1px solid rgba(0,0,0,.12); background: rgba(255,255,255,.7); image-rendering: pixelated; }
.pattern-popover { position: absolute; left: auto; right: 0; bottom: 34px; width: 152px; border: 1px solid rgba(0,0,0,.12); border-radius: 12px; background: rgba(255,255,255,.96); box-shadow: 0 10px 28px rgba(0,0,0,.16); padding: 10px; display: none; box-sizing: border-box; z-index: 40; }
.pattern-popover.is-open { display: block; }
.pattern-popover { max-height: 240px; overflow: auto; }
.pattern-list { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
.pattern-item { height: 34px; border-radius: 10px; border: 1px solid rgba(0,0,0,.12); background: rgba(255,255,255,.8); cursor: pointer; display: grid; place-items: center; padding: 0; }
.pattern-item.is-active { background: rgba(17,17,17,.92); border-color: rgba(0,0,0,.25); }
.pattern-item canvas { width: 22px; height: 22px; image-rendering: pixelated; }
.pattern-item .label { font-size: 10px; opacity: .85; }
.pattern-stage { margin-top: 10px; display: grid; gap: 8px; }
.pattern-edit { display: none; gap: 10px; align-items: center; }
.pattern-edit.is-visible { display: flex; }
.pattern-preview { width: 92px; height: 92px; border-radius: 12px; border: 1px solid rgba(0,0,0,.12); background: rgba(255,255,255,.8); display: grid; place-items: center; }
.pattern-preview canvas { width: 80px; height: 80px; image-rendering: pixelated; }
.pattern-stage .row { display: flex; align-items: center; gap: 8px; }
.palette-btn { width: 26px; height: 26px; border-radius: 10px; border: 1px solid rgba(0,0,0,.12); background: rgba(255,255,255,.92); cursor: pointer; display: grid; place-items: center; padding: 0; box-shadow: 0 2px 10px rgba(0,0,0,.06); }
.palette-btn:active { transform: translateY(1px); }
.palette-btn.is-active { background: rgba(17,17,17,.92); border-color: rgba(0,0,0,.25); }
.palette-btn svg { width: 16px; height: 16px; }
.palette-btn .swatch { width: 8px; height: 8px; border-radius: 999px; border: 1px solid rgba(0,0,0,.18); position: absolute; transform: translate(-3px, 12px); }
.palette-btn .wrap { position: relative; width: 16px; height: 16px; }
.color-layout { display: grid; grid-template-columns: 160px 1fr; gap: 12px; flex: 1; min-height: 0; }
.color-side { display: grid; gap: 10px; }
.card { border: 1px solid rgba(0,0,0,.12); border-radius: 12px; background: rgba(255,255,255,.88); padding: 10px; }
.color-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 6px; }
.color-grid-head { display: flex; justify-content: flex-end; align-items: center; gap: 8px; margin-bottom: 8px; }
.color-cell { display: flex; flex-direction: column; gap: 4px; padding: 6px; border: 1px solid rgba(0,0,0,.10); border-radius: 12px; background: rgba(255,255,255,.75); }
.color-cell input[type="color"] { width: 100%; height: 28px; border: 0; padding: 0; background: transparent; }
.role { font-size: 10px; opacity: .7; }
.color-header { display: flex; justify-content: space-between; align-items: center; gap: 8px; margin-bottom: 10px; }
.color-header strong { font-size: 14px; }
.color-actions { display: flex; align-items: center; gap: 10px; }
.color-actions select { height: 28px; border-radius: 10px; border: 1px solid rgba(0,0,0,.12); background: rgba(255,255,255,.9); padding: 0 8px; }
.outline-colors { display: none; gap: 8px; align-items: center; margin-bottom: 10px; }
.outline-colors .mini { width: 56px; height: 44px; border-radius: 12px; border: 1px solid rgba(0,0,0,.12); background: rgba(255,255,255,.9); padding: 6px; box-sizing: border-box; display: grid; grid-template-rows: 16px 1fr; align-items: center; gap: 4px; }
.outline-colors .mini input[type="color"] { width: 100%; height: 22px; border: 0; padding: 0; background: transparent; }
.outline-colors .mini svg { width: 16px; height: 16px; opacity: .85; }
.preview-wrap { width: 152px; height: 112px; border: 1px solid rgba(0,0,0,.12); border-radius: 10px; overflow: hidden; }
.preview-bg { width: 100%; height: 100%; display: grid; place-items: center; }
.preview-canvas { width: 152px; height: 112px; image-rendering: pixelated; }
</style>
</head>
<body>
<div id="stage" class="stage">
<div class="container">
<div class="sidebar" aria-label="右侧栏">
<div class="toolbar-right" aria-label="工具栏">
  <div class="toolbar-row" aria-label="画笔">
    <button id="pen" class="tool-btn tool-pen" title="铅笔" aria-label="铅笔"><span class="btn-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4Z"/></svg></span></button>
    <button id="pen2" class="tool-btn tool-pen2" title="钢笔" aria-label="钢笔"><span class="btn-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg></span></button>
    <button id="blobby" class="tool-btn tool-icon" title="Blobby" aria-label="Blobby"><span class="btn-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 21c-4.5 0-8-3.2-8-7.6C4 8.8 7.5 6 10.6 6c.8-2 2.3-3 4-3 2.1 0 3.8 1.5 4.2 3.8C20.9 7.7 22 9.5 22 12c0 5-4 9-10 9Z"/></svg></span></button>
  </div>
  <div class="toolbar-row" aria-label="画笔（第二行）">
    <button id="stippleTiny" class="tool-btn tool-icon" title="StippleTiny" aria-label="StippleTiny"><span class="btn-icon"><svg viewBox="0 0 24 24" fill="currentColor"><circle cx="7" cy="7" r="1.2"/><circle cx="12" cy="6" r="1"/><circle cx="17" cy="7.5" r="1.1"/><circle cx="6" cy="12" r="1"/><circle cx="11" cy="12" r="1.3"/><circle cx="16.5" cy="12.5" r="1"/><circle cx="7.5" cy="17" r="1.1"/><circle cx="12.5" cy="18" r="1"/><circle cx="18" cy="17" r="1.2"/></svg></span></button>
    <button id="softLrg" class="tool-btn tool-icon" title="SoftLrg" aria-label="SoftLrg"><span class="btn-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M12 3v3"/><path d="M21 12h-3"/><path d="M12 21v-3"/><path d="M3 12h3"/><path d="M18.4 5.6l-2.1 2.1"/><path d="M7.7 16.3l-2.1 2.1"/><path d="M5.6 5.6l2.1 2.1"/><path d="M16.3 16.3l2.1 2.1"/></svg></span></button>
    <button id="eraser" class="tool-btn tool-eraser" title="橡皮擦" aria-label="橡皮擦"><span class="btn-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 20H9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19H4a2 2 0 0 1-2-2v-1l11.5-12.5Z"/></svg></span></button>
  </div>
  <div class="toolbar-row" aria-label="历史">
    <button id="undo" class="tool-btn tool-undo tool-icon" title="撤销" aria-label="撤销"><span class="btn-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 4v6h6" transform="rotate(45 6 10)"/><path d="M21 17a9 9 0 0 0-9-9H3"/></svg></span></button>
    <button id="redo" class="tool-btn tool-redo tool-icon" title="重做" aria-label="重做"><span class="btn-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 4v6h-6" transform="rotate(-45 20 6)"></path><path d="M3 17a9 9 0 0 1 9-9h9"/></svg></span></button>
    <button id="clear" class="tool-btn tool-clear tool-icon" title="清空" aria-label="清空"><span class="btn-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6V4h8v2"/><path d="M19 6l-1 16H6L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/></svg></span></button>
  </div>
  <div class="toolbar-row" aria-label="操作">
    <button id="switchColor" class="tool-btn tool-color tool-icon" title="换色" aria-label="换色"><span class="btn-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a9 9 0 1 0 0 18c2.2 0 3-1 3-2.5S14 16 12.5 16H12a2 2 0 0 1 0-4h1.2c1.9 0 3.8-1.5 3.8-4.2A4.8 4.8 0 0 0 12 3Z"/><path d="M7.5 10.5h.01"/><path d="M9.5 7.5h.01"/><path d="M14.5 7.5h.01"/><path d="M16.5 10.5h.01"/></svg></span></button>
    <button id="advanced" class="tool-btn tool-advanced tool-icon" title="高级" aria-label="高级"><span class="btn-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="21" x2="4" y2="14"/><line x1="4" y1="10" x2="4" y2="3"/><line x1="12" y1="21" x2="12" y2="12"/><line x1="12" y1="8" x2="12" y2="3"/><line x1="20" y1="21" x2="20" y2="16"/><line x1="20" y1="12" x2="20" y2="3"/><line x1="2" y1="14" x2="6" y2="14"/><line x1="10" y1="8" x2="14" y2="8"/><line x1="18" y1="16" x2="22" y2="16"/></svg></span></button>
    <div class="file-menu-wrap">
      <button id="fileMenuToggle" type="button" class="tool-btn tool-icon" title="文件" aria-label="文件" aria-haspopup="menu" aria-expanded="false"><span class="btn-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7a2 2 0 0 1 2-2h5l2 2h7a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/></svg></span></button>
      <div id="fileMenu" class="file-menu" role="menu" aria-label="文件操作">
        <button id="exportGif" class="tool-btn tool-export" role="menuitem">导出GIF</button>
        <button id="importGif" class="tool-btn tool-importgif" role="menuitem">导入GIF</button>
        <button id="importBg" class="tool-btn tool-importbg" role="menuitem">导入背景</button>
      </div>
    </div>
  </div>
</div>
<div class="toolbar-left" aria-label="颜色与图案">
  <div class="pattern-picker" aria-label="图案设置">
    <button id="patternSelect" type="button" class="pattern-select" aria-haspopup="dialog" aria-expanded="false">
      <canvas id="patternThumb" class="thumb" width="18" height="18"></canvas>
      <span id="patternSelectLabel">默认图案</span>
    </button>
    <div id="patternPopover" class="pattern-popover" role="dialog" aria-label="图案选择">
      <div id="patternList" class="pattern-list" aria-label="图案列表"></div>
      <div id="patternStage" class="pattern-stage" aria-label="图案编辑">
        <div class="row">
          <button id="patternUpload" type="button" class="action-btn">上传图案</button>
        </div>
        <div id="patternEdit" class="pattern-edit">
          <div class="pattern-preview"><canvas id="patternPreview" width="32" height="32"></canvas></div>
          <div style="display:grid;gap:8px;">
            <button id="patternInvert" type="button" class="action-btn">反色</button>
            <button id="patternConfirm" type="button" class="action-btn">确定</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="paletteTools" class="palette-panel" aria-label="16色调色板笔"></div>
</div>
<div class="sidebar-footer" aria-label="底部按钮">
  <button id="aboutBtn" type="button" class="action-btn" title="关于" aria-label="关于"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg></button>
  <button id="animBtn" type="button" class="action-btn" title="动画" aria-label="动画"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18V6l12 6-12 6Z"/><path d="M3 6v12"/></svg></button>
  <div class="zoom-menu-wrap">
    <button id="zoomBtn" type="button" class="action-btn" title="画布缩放" aria-label="画布缩放" aria-haspopup="dialog" aria-expanded="false"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="7"/><path d="M21 21l-4.3-4.3"/><path d="M11 8v6"/><path d="M8 11h6"/></svg></button>
    <div id="zoomMenu" class="zoom-menu" role="dialog" aria-label="画布缩放">
      <div class="row">
        <button id="zoomOut" type="button" class="action-btn zoom-icon-btn" aria-label="缩小"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/></svg></button>
        <div class="zoom-controls">
          <input id="canvasZoom" type="range" min="50" max="300" step="10" value="100" aria-label="画布缩放百分比">
          <span id="canvasZoomValue" class="pill">100%</span>
        </div>
        <button id="zoomIn" type="button" class="action-btn zoom-icon-btn" aria-label="放大"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"/><path d="M5 12h14"/></svg></button>
      </div>
      <div class="row">
      <label class="toggle"><input id="canvasPanMode" type="checkbox"><span>拖动内容</span></label>
      <button id="zoomReset" type="button" class="action-btn zoom-icon-btn" aria-label="重置为100%">100%</button>
      </div>
    </div>
  </div>
  <button id="cropBtn" type="button" class="action-btn" title="裁剪" aria-label="裁剪"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2v14a2 2 0 0 0 2 2h14"/><path d="M18 22V8a2 2 0 0 0-2-2H2"/></svg></button>
  <button id="selectBtn" type="button" class="action-btn" title="选择" aria-label="选择"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="16" height="16" rx="2" ry="2" stroke-dasharray="4 3"/></svg></button>
</div>
</div>
<div class="jitter-panel">
  <div id="jitterControls">
    <div class="row">
      <label class="toggle"><input id="jitterOn" type="checkbox" checked><span>抖动</span></label>
      <div class="range">
        <input id="jitter" type="range" min="0" max="10" step="1" value="1">
        <span id="jitterValue" class="pill">1</span>
      </div>
    </div>
    <div class="row">
      <span class="label">内部延时(ms)</span>
      <input id="jitterDelay" type="number" min="20" step="10" value="120">
    </div>
  </div>
  <div id="eraserControls" style="display:none">
    <div class="row">
      <label class="toggle"><input id="eraseOnlyOutline" type="checkbox"><span>只擦勾线</span></label>
    </div>
    <div class="row">
      <label class="toggle"><input id="eraseOnlyEraser" type="checkbox"><span>不擦勾线</span></label>
    </div>
  </div>
  <div class="row">
    <label class="toggle"><input id="protectOutline" type="checkbox" checked><span>勾线笔不允许被覆盖</span></label>
  </div>
  <div class="row">
    <span class="label">粗细</span>
    <div class="range">
      <input id="size" type="range" min="1" max="31" step="1" value="1">
      <span id="sizeValue" class="pill">1</span>
    </div>
  </div>
</div>
<input id="patternFile" type="file" accept="image/*" style="display:none">
<input id="gifFile" type="file" accept="image/gif" style="display:none">
<input id="bgFile" type="file" accept="image/*" style="display:none">
<div id="canvasViewport" class="canvas-viewport">
  <div id="checkerboard" class="checkerboard"></div>
  <div id="canvasBg" class="canvas-bg"></div>
  <canvas id="drawing" class="canvas" width="360" height="342"></canvas>
</div>
<div id="colorPage" class="overlay">
  <div class="color-header">
    <span></span>
    <div class="color-actions">
      <select id="schemeSelect" aria-label="配色方案"></select>
      <label class="toggle"><input type="checkbox" id="toggleTransparent"><span>透明背景</span></label>
      <label class="toggle"><input id="separateOutline" type="checkbox"><span>区分勾线笔颜色</span></label>
      <button id="back" class="action-btn">返回绘制</button>
    </div>
  </div>
  <div id="outlineColors" class="outline-colors">
    <div class="mini" title="勾线笔 1">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4Z"/></svg>
      <input type="color" data-index="17">
    </div>
    <div class="mini" title="勾线笔 2">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg>
      <input type="color" data-index="18">
    </div>
    <div class="mini" title="勾线笔 3">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 21c-4.5 0-8-3.2-8-7.6C4 8.8 7.5 6 10.6 6c.8-2 2.3-3 4-3 2.1 0 3.8 1.5 4.2 3.8C20.9 7.7 22 9.5 22 12c0 5-4 9-10 9Z"/></svg>
      <input type="color" data-index="19">
    </div>
    <div class="mini" title="勾线笔 4">
      <svg viewBox="0 0 24 24" fill="currentColor"><circle cx="7" cy="7" r="1.2"/><circle cx="12" cy="6" r="1"/><circle cx="17" cy="7.5" r="1.1"/><circle cx="6" cy="12" r="1"/><circle cx="11" cy="12" r="1.3"/><circle cx="16.5" cy="12.5" r="1"/><circle cx="7.5" cy="17" r="1.1"/><circle cx="12.5" cy="18" r="1"/><circle cx="18" cy="17" r="1.2"/></svg>
      <input type="color" data-index="20">
    </div>
    <div class="mini" title="勾线笔 5">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M12 3v3"/><path d="M21 12h-3"/><path d="M12 21v-3"/><path d="M3 12h3"/><path d="M18.4 5.6l-2.1 2.1"/><path d="M7.7 16.3l-2.1 2.1"/><path d="M5.6 5.6l2.1 2.1"/><path d="M16.3 16.3l2.1 2.1"/></svg>
      <input type="color" data-index="21">
    </div>
  </div>
  <div class="color-layout">
    <div class="color-side">
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
          <span>预览</span>
        </div>
        <div class="preview-wrap">
          <div id="previewBg" class="preview-bg">
            <canvas id="preview" class="preview-canvas" width="152" height="112"></canvas>
          </div>
        </div>
      </div>
    </div>
    <div class="card">
      <div class="color-grid-head">
        <button id="schemeReset" type="button" class="action-btn">重置</button>
        <button id="schemeSave" type="button" class="action-btn">保存</button>
      </div>
      <div class="color-grid">
        <div class="color-cell"><span class="role">背景色</span><input type="color" data-index="1"></div>
        <div class="color-cell"><span class="role">前景色</span><input type="color" data-index="2"></div>
        <div class="color-cell"><input type="color" data-index="3"></div>
        <div class="color-cell"><input type="color" data-index="4"></div>
        <div class="color-cell"><input type="color" data-index="5"></div>
        <div class="color-cell"><input type="color" data-index="6"></div>
        <div class="color-cell"><input type="color" data-index="7"></div>
        <div class="color-cell"><input type="color" data-index="8"></div>
        <div class="color-cell"><input type="color" data-index="9"></div>
        <div class="color-cell"><input type="color" data-index="10"></div>
        <div class="color-cell"><input type="color" data-index="11"></div>
        <div class="color-cell"><input type="color" data-index="12"></div>
        <div class="color-cell"><input type="color" data-index="13"></div>
        <div class="color-cell"><input type="color" data-index="14"></div>
        <div class="color-cell"><input type="color" data-index="15"></div>
        <div class="color-cell"><input type="color" data-index="16"></div>
      </div>
    </div>
</div>
</div>
<div id="aboutModal" class="modal-overlay" role="dialog" aria-modal="true" aria-label="关于">
  <div class="modal-card">
    <div class="modal-head">
      <strong>关于</strong>
      <button id="aboutClose" type="button" class="action-btn">关闭</button>
    </div>
    <div class="modal-body">
      <div>作者：雪风与梦 (网名)</div>
      <div>参考 wigglypaint（作者:Internet Janitor，John Earnest）</div>
    </div>
  </div>
</div>
<div id="animModal" class="modal-overlay" role="dialog" aria-modal="true" aria-label="动画">
  <div class="modal-card anim-card">
    <div class="modal-head">
      <strong>动画</strong>
      <div class="anim-row">
        <button id="animPlayClose" type="button" class="action-btn">播放并关闭</button>
        <button id="animClose" type="button" class="action-btn">关闭</button>
      </div>
    </div>
    <div class="anim-bar">
      <div class="anim-row">
        <button id="animNewFrame" type="button" class="action-btn">新建帧</button>
        <button id="animDeleteFrame" type="button" class="action-btn">删除帧</button>
        <button id="animMultiSelect" type="button" class="action-btn">多选</button>
        <button id="animPlay" type="button" class="action-btn">播放</button>
      </div>
    </div>
    <div id="animFrameList" class="anim-frames" aria-label="帧列表"></div>
    <div class="anim-row" style="margin-top:10px;">
      <span class="label">持续时间(ms)</span>
      <input id="animDelay" type="number" min="30" step="10" value="360">
      <button id="animApplyAllDelay" type="button" class="action-btn">应用到所有帧</button>
      <button id="animExportGif" type="button" class="action-btn">导出GIF</button>
    </div>
  </div>
</div>
</div>
</div>
<script type="module">
import { GIFEncoder } from 'https://unpkg.com/gifenc@1.0.3';
import { parseGIF, decompressFrames } from 'https://esm.sh/gifuct-js@2.1.2';
const stageEl=document.getElementById('stage');
const containerEl=document.querySelector('.container');
const zoomBtnEl=document.getElementById('zoomBtn');
const zoomMenuEl=document.getElementById('zoomMenu');
function applyStageScale(){
  const vw=window.innerWidth||0;
  const vh=window.innerHeight||0;
  const pad=16;
  const s=Math.min(1,(vw-pad)/512,(vh-pad)/342);
  const scale=(Number.isFinite(s)&&s>0)?s:1;
  if(stageEl){
    stageEl.style.width=`${Math.round(512*scale)}px`;
    stageEl.style.height=`${Math.round(342*scale)}px`;
  }
  if(containerEl){
    containerEl.style.transform=`scale(${scale})`;
  }
  if(zoomBtnEl){
    const open=Boolean(zoomMenuEl && zoomMenuEl.classList.contains('is-open'));
    zoomBtnEl.classList.toggle('is-active',open);
    zoomBtnEl.setAttribute('aria-expanded',open?'true':'false');
  }
}
applyStageScale();
window.addEventListener('resize',applyStageScale);
window.addEventListener('orientationchange',applyStageScale);
// ===== 画布/数据模型 =====
// 为了实现“沸腾抖动”的播放效果，这里用 4 帧像素数据来表示同一张画：
// - 帧 0/1/2：抖动模式下循环播放（会对每段新线条端点做随机偏移）
// - 帧 3：稳定帧（不抖动），用于非抖动显示与换色界面预览
// 每个像素存的是 0~16 的“颜色值”，渲染时再用颜色映射表把它变成真正的颜色。
// 约定：0 是“透明/橡皮擦”，不参与换色；1~16 才是可换色的调色板。
const canvas=document.getElementById('drawing');
const canvasViewportEl=document.getElementById('canvasViewport');
const canvasBgEl=document.getElementById('canvasBg');
const ctx=canvas.getContext('2d');
const W=canvas.width,H=canvas.height;
const MAX_COLOR_INDEX=21;
const BASE_COLOR_COUNT=16;
const OUTLINE_FIRST=17;
const OUTLINE_LAST=21;
const frames=[
  new Uint8Array(W*H),
  new Uint8Array(W*H),
  new Uint8Array(W*H),
  new Uint8Array(W*H),
];
// 颜色映射：值 0~16 -> 颜色
// 约定：值 1 为背景色，值 2 为前景色（第一只笔）
const defaultColors=['#000000','#ffffff','#000000','#00ff00','#0000ff','#ffff00','#ff00ff','#00ffff','#888888','#444444','#ffa500','#800080','#008000','#000080','#808000','#800000','#ff0000','#000000','#000000','#000000','#000000','#000000'];
const colorMap=defaultColors.slice();
let currentTool='pencil';
let paletteValue=2;
let jitterLevel=0;
let displayFrame=3;
let animId=null;
let drawing=false;
let last=null;
const penBtn=document.getElementById('pen');
const pen2Btn=document.getElementById('pen2');
const blobbyBtn=document.getElementById('blobby');
const stippleTinyBtn=document.getElementById('stippleTiny');
const softLrgBtn=document.getElementById('softLrg');
const eraserBtn=document.getElementById('eraser');
const clearBtn=document.getElementById('clear');
const undoBtn=document.getElementById('undo');
const redoBtn=document.getElementById('redo');
const exportGifBtn=document.getElementById('exportGif');
const importGifBtn=document.getElementById('importGif');
const importBgBtn=document.getElementById('importBg');
const advancedBtn=document.getElementById('advanced');
const separateOutlineEl=document.getElementById('separateOutline');
const protectOutlineEl=document.getElementById('protectOutline');
const outlineColorsEl=document.getElementById('outlineColors');
const paletteToolsEl=document.getElementById('paletteTools');
const patternPickerEl=document.querySelector('.pattern-picker');
const patternSelectBtn=document.getElementById('patternSelect');
const patternSelectLabelEl=document.getElementById('patternSelectLabel');
const patternThumbCanvas=document.getElementById('patternThumb');
const patternThumbCtx=patternThumbCanvas.getContext('2d');
patternThumbCtx.imageSmoothingEnabled=false;
const patternPopoverEl=document.getElementById('patternPopover');
const patternListEl=document.getElementById('patternList');
const patternEditEl=document.getElementById('patternEdit');
const patternPreviewCanvas=document.getElementById('patternPreview');
const patternPreviewCtx=patternPreviewCanvas.getContext('2d');
patternPreviewCtx.imageSmoothingEnabled=false;
const patternUploadBtn=document.getElementById('patternUpload');
const patternInvertBtn=document.getElementById('patternInvert');
const patternConfirmBtn=document.getElementById('patternConfirm');
const patternFileEl=document.getElementById('patternFile');
const gifFileEl=document.getElementById('gifFile');
const bgFileEl=document.getElementById('bgFile');
let customBgUrl='';
const outlineColorStore=Array.from({length: MAX_COLOR_INDEX+1},()=>null);
for(let i=OUTLINE_FIRST;i<=OUTLINE_LAST;i++){
  outlineColorStore[i]=colorMap[i] ?? colorMap[2];
}
function syncOutlineColorMap(){
  const separate=Boolean(separateOutlineEl && separateOutlineEl.checked);
  for(let i=OUTLINE_FIRST;i<=OUTLINE_LAST;i++){
    colorMap[i]=separate ? (outlineColorStore[i] ?? colorMap[2]) : colorMap[2];
  }
}
syncOutlineColorMap();
const toolSettings={
  eraser:{ size:11 },
  pencil:{ size:1 },
  pen:{ size:3 },
  palette:{ size:5 },
  blobby:{ size:9 },
  stippleTiny:{ size:5 },
  softLrg:{ size:15 },
};
const sizeEl=document.getElementById('size');
const sizeValueEl=document.getElementById('sizeValue');
const undoStack=[];
const redoStack=[];
const MAX_HISTORY=80;
function cloneFrames(){
  return frames.map(f=>new Uint8Array(f));
}
function applyFrames(snapshot){
  for(let i=0;i<frames.length;i++){
    frames[i].set(snapshot[i]);
  }
}
function syncHistoryUI(){
  undoBtn.disabled=undoStack.length===0;
  redoBtn.disabled=redoStack.length===0;
}
function pushHistory(){
  undoStack.push(cloneFrames());
  if(undoStack.length>MAX_HISTORY) undoStack.shift();
  redoStack.length=0;
  syncHistoryUI();
}
function undo(){
  if(undoStack.length===0) return;
  redoStack.push(cloneFrames());
  const prev=undoStack.pop();
  applyFrames(prev);
  syncHistoryUI();
  renderCurrent();
}
function redo(){
  if(redoStack.length===0) return;
  undoStack.push(cloneFrames());
  const next=redoStack.pop();
  applyFrames(next);
  syncHistoryUI();
  renderCurrent();
}
undoBtn.addEventListener('click',undo);
redoBtn.addEventListener('click',redo);
window.addEventListener('keydown',e=>{
  if(e.target && (e.target.tagName==='INPUT' || e.target.tagName==='SELECT' || e.target.tagName==='TEXTAREA')) return;
  const isMac=navigator.platform.toLowerCase().includes('mac');
  const ctrl=isMac ? e.metaKey : e.ctrlKey;
  if(!ctrl) return;
  const key=(e.key||'').toLowerCase();
  if(key==='z'){
    e.preventDefault();
    if(e.shiftKey) redo();
    else undo();
  }else if(key==='y'){
    e.preventDefault();
    redo();
  }
});
function setTool(tool){
  // 切换当前工具，并同步 UI（激活态/粗细/抖动可用性）
  if(canvasPanMode) setCanvasPanMode(false);
  currentTool=tool;
  penBtn.classList.toggle('is-active',tool==='pencil');
  pen2Btn.classList.toggle('is-active',tool==='pen');
  blobbyBtn.classList.toggle('is-active',tool==='blobby');
  stippleTinyBtn.classList.toggle('is-active',tool==='stippleTiny');
  softLrgBtn.classList.toggle('is-active',tool==='softLrg');
  eraserBtn.classList.toggle('is-active',tool==='eraser');
  sizeEl.value=String(toolSettings[tool]?.size ?? 1);
  sizeValueEl.textContent=String(toolSettings[tool]?.size ?? 1);
  const erasing=tool==='eraser';
  jitter.disabled=erasing;
  jitterValue.style.opacity=erasing?'.5':'1';
  if(jitterControlsEl && eraserControlsEl){
    jitterControlsEl.style.display=erasing?'none':'block';
    eraserControlsEl.style.display=erasing?'block':'none';
  }
  syncPaletteButtonsActive();
}
function getPaintValue(){
  if(currentTool==='eraser') return 0;
  if(currentTool==='pencil') return 17;
  if(currentTool==='pen') return 18;
  if(currentTool==='blobby') return 19;
  if(currentTool==='stippleTiny') return 20;
  if(currentTool==='softLrg') return 21;
  return paletteValue;
}
function getPos(e){
  // 把鼠标坐标换算到 canvas 像素坐标（避免缩放导致的偏差）
  const rect=canvas.getBoundingClientRect();
  const x=Math.round((e.clientX-rect.left)*(canvas.width/rect.width));
  const y=Math.round((e.clientY-rect.top)*(canvas.height/rect.height));
  return {x,y};
}
function setPixel(frame,x,y,val){
  if(x<0||y<0||x>=W||y>=H) return;
  const v=val|0;
  const idx=y*W+x;
  const next=(v<0?0:(v>MAX_COLOR_INDEX?MAX_COLOR_INDEX:v));
  if(next===0 && currentTool==='eraser'){
    const cur=frame[idx];
    const isOutline=(cur>=OUTLINE_FIRST && cur<=OUTLINE_LAST);
    if(eraseOnlyOutlineEl && eraseOnlyOutlineEl.checked && !isOutline) return;
    if(eraseOnlyEraserEl && eraseOnlyEraserEl.checked && isOutline) return;
  }
  if(protectOutlineEl && protectOutlineEl.checked){
    const cur=frame[idx];
    const curIsOutline=(cur>=OUTLINE_FIRST && cur<=OUTLINE_LAST);
    const nextIsOutline=(next>=OUTLINE_FIRST && next<=OUTLINE_LAST);
    if(curIsOutline && !nextIsOutline && next!==0) return;
  }
  frame[idx]=next;
}
function stamp(frame,x,y,val,size){
  // 把“粗细”转换成一个圆形像素章，盖到当前帧上
  const r=Math.floor(size/2);
  if(r<=0){ setPixel(frame,x,y,val); return; }
  const r2=r*r;
  for(let dy=-r;dy<=r;dy++){
    const yy=y+dy;
    if(yy<0||yy>=H) continue;
    for(let dx=-r;dx<=r;dx++){
      if(dx*dx+dy*dy>r2) continue;
      const xx=x+dx;
      if(xx<0||xx>=W) continue;
      setPixel(frame,xx,yy,val);
    }
  }
}
const PATTERN_W=32;
const PATTERN_H=32;
const patterns=[{ id:'default', mask:null }];
let activePatternId='default';
let pendingMask32=null;
let nextPatternId=1;
function stampPattern(frame,x,y,val,size,brush){
  const w=brush.w, h=brush.h;
  const mask=brush.mask;
  const s=Math.max(1,size|0);
  const left=x-Math.floor(s/2);
  const top=y-Math.floor(s/2);
  for(let oy=0;oy<s;oy++){
    const my=Math.floor(oy*h/s);
    for(let ox=0;ox<s;ox++){
      const mx=Math.floor(ox*w/s);
      if(mask[my*w+mx]!==1) continue;
      setPixel(frame,left+ox,top+oy,val);
    }
  }
}
function getBrushForSize(patternId){
  if(!patternId || patternId==='default') return null;
  const p=patterns.find(x=>x.id===patternId);
  const baseMask=p && p.mask;
  if(!baseMask) return null;
  return { w:PATTERN_W, h:PATTERN_H, mask: baseMask };
}
function stampPalette(frame,x,y,val,size){
  const brush=getBrushForSize(activePatternId);
  if(brush){ stampPattern(frame,x,y,val,size,brush); return; }
  stamp(frame,x,y,val,size);
}
function clampBrushSize(n){
  const v=n|0;
  if(v<1) return 1;
  if(v>31) return 31;
  return v;
}
const STIPPLE_TINY_BRUSHES=[
  { w:4, h:4, mask:new Uint8Array([1,0,0,0, 0,0,1,0, 0,1,0,0, 0,0,0,1]) },
  { w:4, h:4, mask:new Uint8Array([0,1,0,0, 0,0,0,1, 1,0,0,0, 0,0,1,0]) },
  { w:4, h:4, mask:new Uint8Array([0,0,1,0, 1,0,0,0, 0,0,0,1, 0,1,0,0]) },
  { w:4, h:4, mask:new Uint8Array([0,0,0,1, 0,1,0,0, 0,0,1,0, 1,0,0,0]) },
  { w:4, h:4, mask:new Uint8Array([1,0,1,0, 0,0,0,0, 0,1,0,1, 0,0,0,0]) },
  { w:4, h:4, mask:new Uint8Array([0,0,0,0, 1,0,0,1, 0,0,0,0, 1,0,0,1]) },
  { w:4, h:4, mask:new Uint8Array([0,1,0,1, 0,0,0,0, 1,0,1,0, 0,0,0,0]) },
  { w:4, h:4, mask:new Uint8Array([0,0,1,0, 0,0,0,0, 1,0,0,1, 0,0,0,0]) },
];
const SOFT_LRG_POINT_SETS=[
  [[5,1],[4,10],[9,10],[10,1]],[[12,2],[8,13],[7,14],[4,13]],[[4,9],[7,10],[12,9],[14,4]],[[4,3],[9,2],[9,8],[6,8]],
  [[13,9],[7,9],[13,5],[11,9]],[[10,12],[8,3],[11,7],[3,7]],[[1,9],[6,2],[4,12],[3,6]],[[5,14],[8,14],[11,12],[15,5]],
  [[1,3],[11,1],[3,4],[2,5]],[[3,11],[5,4],[10,3],[0,8]],[[14,9],[11,5],[10,8],[8,4]],[[11,2],[10,0],[2,10],[11,14]],
  [[5,7],[14,5],[0,9],[4,2]],[[1,7],[13,4],[2,3],[13,3]],[[3,14],[3,10],[7,4],[12,8]],[[6,0],[3,9],[1,8],[12,7]],
  [[4,14],[14,10],[5,0],[9,3]],[[14,3],[3,12],[11,3],[9,1]],[[3,3],[13,6],[2,12],[7,6]],[[3,2],[11,8],[4,8],[8,0]],
  [[7,2],[2,4],[8,11],[12,10]],[[8,1],[9,7],[8,12],[13,7]],[[15,7],[13,8],[10,11],[2,2]],[[6,1],[8,6],[8,7],[0,6]],
  [[4,4],[10,2],[4,1],[4,5]],[[5,2],[6,10],[14,6],[9,4]],[[5,5],[10,6],[5,3],[7,13]],[[12,13],[3,1],[14,8],[5,12]],
  [[5,15],[8,15],[11,6],[12,11]],[[3,8],[12,14],[6,9],[6,5]],[[0,7],[3,5],[7,11],[1,6]],[[6,7],[4,6],[12,6],[2,11]],
  [[13,2],[6,3],[10,9],[10,4]],[[6,15],[8,9],[13,10],[8,8]],[[8,5],[10,5],[5,11],[15,6]],[[4,7],[0,10],[8,2],[10,13]],
  [[11,4],[13,11],[14,11],[5,10]],[[12,1],[7,7],[14,7],[14,12]],[[6,11],[5,9],[3,13],[9,13]],[[7,8],[10,10],[7,3],[7,15]],
  [[9,11],[6,6],[4,11],[2,13]],[[7,12],[11,11],[9,14],[7,1]],[[15,10],[2,8],[1,5],[9,0]],[[15,8],[10,14],[10,7],[9,12]],
  [[1,10],[9,5],[15,9],[1,11]],[[0,5],[6,14],[1,4],[7,5]],[[1,12],[9,15],[10,15],[5,8]],[[5,6],[12,12],[11,10],[12,3]],
  [[9,6],[6,12],[7,0],[12,5]],[[11,13],[8,10],[2,7],[6,13]],[[13,13],[9,9],[2,9],[12,4]],[[5,13],[13,12],[2,6],[6,4]],
];
function buildSoftLrgBrushes(){
  const out=[];
  for(const set of SOFT_LRG_POINT_SETS){
    const mask=new Uint8Array(16*16);
    for(const p of set){
      const x=p[0]|0;
      const y=p[1]|0;
      if(x<0||y<0||x>=16||y>=16) continue;
      mask[y*16+x]=1;
    }
    out.push({ w:16, h:16, mask });
  }
  return out;
}
const SOFT_LRG_BRUSHES=buildSoftLrgBrushes();
function stampTool(frame,x,y,val,tool,deltaMag){
  const baseSize=toolSettings[tool]?.size ?? 1;
  if(tool==='blobby'){
    const bump=Math.min(14,Math.round((deltaMag||0)*0.5));
    const s=clampBrushSize(baseSize+bump);
    stamp(frame,x,y,val,s);
    return;
  }
  if(tool==='stippleTiny'){
    const brush=STIPPLE_TINY_BRUSHES[(Math.random()*STIPPLE_TINY_BRUSHES.length)|0];
    stampPattern(frame,x,y,val,clampBrushSize(baseSize),brush);
    return;
  }
  if(tool==='softLrg'){
    const brush=SOFT_LRG_BRUSHES[(Math.random()*SOFT_LRG_BRUSHES.length)|0];
    stampPattern(frame,x,y,val,clampBrushSize(baseSize),brush);
    return;
  }
  stamp(frame,x,y,val,clampBrushSize(baseSize));
}
function drawLineTool(frame,a,b,val,tool){
  const dx=b.x-a.x;
  const dy=b.y-a.y;
  const steps=Math.max(Math.abs(dx),Math.abs(dy));
  const deltaMag=Math.hypot(dx,dy);
  if(steps===0){
    stampTool(frame,a.x,a.y,val,tool,deltaMag);
    return;
  }
  for(let i=0;i<=steps;i++){
    const t=i/steps;
    const x=Math.round(a.x+t*dx);
    const y=Math.round(a.y+t*dy);
    stampTool(frame,x,y,val,tool,deltaMag);
  }
}
function drawLineValue(frame,a,b,val,size){
  // 线段离散为很多个像素点，每个点用 stamp 来保证粗细
  const dx=b.x-a.x,dy=b.y-a.y;
  const steps=Math.max(Math.abs(dx),Math.abs(dy));
  if(steps===0){ stamp(frame,a.x,a.y,val,size); return; }
  for(let i=0;i<=steps;i++){
    const t=i/steps;
    const x=Math.round(a.x+t*dx);
    const y=Math.round(a.y+t*dy);
    stamp(frame,x,y,val,size);
  }
}
function randOffset(maxAbs){
  return Math.round((Math.random()*2-1)*maxAbs);
}
let jitterStrokeId=1;
let jitterSegId=0;
function hash32(n){
  let x=n|0;
  x=Math.imul(x^(x>>>16),0x45d9f3b);
  x=Math.imul(x^(x>>>16),0x45d9f3b);
  x=(x^(x>>>16))>>>0;
  return x;
}
function jitterOffset(seed,maxAbs){
  if(maxAbs<=0) return 0;
  const span=maxAbs*2+1;
  return (hash32(seed)%span)-maxAbs;
}
function nextJitterBase(){
  return ((jitterStrokeId&0xffff)<<16) ^ (jitterSegId++ & 0xffff);
}
function makeFrameOffsets(base,maxAbs){
  const out=[];
  for(let fi=0;fi<3;fi++){
    const dx=jitterOffset(base+fi*131,maxAbs);
    const dy=jitterOffset(base+fi*131+77,maxAbs);
    out.push({dx,dy});
  }
  if(maxAbs>0){
    const fix=[{dx:-maxAbs,dy:0},{dx:0,dy:maxAbs},{dx:maxAbs,dy:0}];
    const allSame=out[0].dx===out[1].dx && out[0].dy===out[1].dy && out[0].dx===out[2].dx && out[0].dy===out[2].dy;
    if(allSame){
      out[0]=fix[0]; out[1]=fix[1]; out[2]=fix[2];
    }else{
      for(let i=0;i<3;i++){
        for(let j=0;j<i;j++){
          if(out[i].dx===out[j].dx && out[i].dy===out[j].dy){
            out[i]=fix[i];
          }
        }
      }
    }
  }
  return out;
}
function hexToRGB(hex){
  const h=hex.replace('#','');
  const r=parseInt(h.slice(0,2),16);
  const g=parseInt(h.slice(2,4),16);
  const b=parseInt(h.slice(4,6),16);
  return [r,g,b];
}
function render(frame){
  // 把“颜色值帧”渲染成 RGBA 像素；值 0 代表透明
  const img=ctx.createImageData(W,H);
  const data=img.data;
  for(let i=0;i<frame.length;i++){
    const val=frame[i];
    const o=i*4;
    if(val===0){
      data[o]=0; data[o+1]=0; data[o+2]=0; data[o+3]=0;
    }else{
      const [r,g,b]=hexToRGB(colorMap[val]);
      data[o]=r; data[o+1]=g; data[o+2]=b; data[o+3]=255;
    }
  }
  ctx.putImageData(img,0,0);
}
const previewCanvas=document.getElementById('preview');
const previewCtx=previewCanvas.getContext('2d');
previewCtx.imageSmoothingEnabled=false;
function renderPreview(){
  // 换色界面预览固定看“稳定帧” frame3
  // 直接按预览尺寸采样渲染，避免每次都生成 360x265 的大 ImageData（系统颜色选择器拖动时会卡）
  const pw=previewCanvas.width, ph=previewCanvas.height;
  const img=previewCtx.createImageData(pw,ph);
  const data=img.data;
  const frame=frames[3];
  for(let y=0;y<ph;y++){
    const sy=Math.floor(y*H/ph);
    for(let x=0;x<pw;x++){
      const sx=Math.floor(x*W/pw);
      const val=frame[sy*W+sx];
      const o=(y*pw+x)*4;
      if(val===0){
        data[o]=0; data[o+1]=0; data[o+2]=0; data[o+3]=0;
      }else{
        const [r,g,b]=hexToRGB(colorMap[val]);
        data[o]=r; data[o+1]=g; data[o+2]=b; data[o+3]=255;
      }
    }
  }
  previewCtx.putImageData(img,0,0);
}
function renderCurrent(){
  // 换色界面不显示绘画区，跳过大画布渲染，避免调色时卡顿
  if(!container.classList.contains('color-mode')){
    render(frames[displayFrame]);
  }
  renderPreview();
}
function startAnim(){
  // 抖动开启时循环播放 frame0~2
  stopAnim();
  const tick=()=>{
    displayFrame=(displayFrame+1)%3;
    renderCurrent();
    animId=window.setTimeout(tick,getJitterSubDelayMs(displayFrame));
  };
  animId=window.setTimeout(tick,getJitterSubDelayMs(displayFrame));
}
function stopAnim(){
  if(animId!==null){
    window.clearTimeout(animId);
    animId=null;
  }
}
function applyPlaybackMode(){
  if(jitterOnEl && jitterOnEl.checked){
    stopAnim();
    displayFrame=0;
    renderCurrent();
    startAnim();
  }else{
    stopAnim();
    displayFrame=3;
    renderCurrent();
  }
}
function drawSegment(from,to,val){
  const size=toolSettings[currentTool]?.size ?? 1;
  const erasing=val===0;
  if(erasing){
    for(let fi=0;fi<4;fi++){
      drawLineValue(frames[fi],from,to,val,size);
    }
    return;
  }
  const baseJitter=(jitterLevel||0);
  const toolJitterScale=(currentTool==='pencil') ? 2 : 1;
  const maxAbs=baseJitter*toolJitterScale;
  const jitterActive=maxAbs>0;
  if(currentTool==='palette'){
    if(jitterActive){
      const base=nextJitterBase();
      const offsets=makeFrameOffsets(base,maxAbs);
      for(let fi=0;fi<3;fi++){
        const o=offsets[fi];
        stampPalette(frames[fi],to.x+o.dx,to.y+o.dy,val,size);
      }
    }else{
      for(let fi=0;fi<3;fi++){
        stampPalette(frames[fi],to.x,to.y,val,size);
      }
    }
    stampPalette(frames[3],to.x,to.y,val,size);
    return;
  }
  if(currentTool==='blobby' || currentTool==='stippleTiny' || currentTool==='softLrg'){
    if(jitterActive){
      const base=nextJitterBase();
      const offsets=makeFrameOffsets(base,maxAbs);
      for(let fi=0;fi<3;fi++){
        const o=offsets[fi];
        drawLineTool(frames[fi],{x:from.x+o.dx,y:from.y+o.dy},{x:to.x+o.dx,y:to.y+o.dy},val,currentTool);
      }
    }else{
      for(let fi=0;fi<3;fi++){
        drawLineTool(frames[fi],from,to,val,currentTool);
      }
    }
    drawLineTool(frames[3],from,to,val,currentTool);
    return;
  }
  if(jitterActive){
    const base=nextJitterBase();
    const offsets=makeFrameOffsets(base,maxAbs);
    for(let fi=0;fi<3;fi++){
      const o=offsets[fi];
      drawLineValue(frames[fi],{x:from.x+o.dx,y:from.y+o.dy},{x:to.x+o.dx,y:to.y+o.dy},val,size);
    }
  }else{
    for(let fi=0;fi<3;fi++){
      drawLineValue(frames[fi],from,to,val,size);
    }
  }
  drawLineValue(frames[3],from,to,val,size);
}
function pointerCanDraw(e){
  if(e.button!=null && e.button!==0) return false;
  return true;
}
let canvasPanMoveListener=null;
let canvasPanUpListener=null;
function startCanvasPan(e){
  e.preventDefault();
  canvasPanning=true;
  canvasPanPointerId=e.pointerId;
  canvasPanStart={ x:e.clientX, y:e.clientY };
  canvasPanBase={ x:canvasViewPanX, y:canvasViewPanY };
  if(canvasViewportEl) canvasViewportEl.style.cursor='grabbing';
  else if(canvas) canvas.style.cursor='grabbing';
  if(canvasPanMoveListener || canvasPanUpListener){
    try{ if(canvasPanMoveListener) window.removeEventListener('pointermove',canvasPanMoveListener,true); }catch{}
    try{ if(canvasPanUpListener) window.removeEventListener('pointerup',canvasPanUpListener,true); }catch{}
    try{ if(canvasPanUpListener) window.removeEventListener('pointercancel',canvasPanUpListener,true); }catch{}
  }
  const onMove=(ev)=>{
    if(!canvasPanning) return;
    if(ev.pointerId!==canvasPanPointerId) return;
    ev.preventDefault();
    const dx=ev.clientX-(canvasPanStart?.x ?? ev.clientX);
    const dy=ev.clientY-(canvasPanStart?.y ?? ev.clientY);
    canvasViewPanX=(canvasPanBase?.x ?? canvasViewPanX)+dx;
    canvasViewPanY=(canvasPanBase?.y ?? canvasViewPanY)+dy;
    clampCanvasPan();
    applyCanvasViewTransform();
  };
  const onUp=(ev)=>{
    if(ev.pointerId!==canvasPanPointerId) return;
    stopDrawing(ev);
  };
  canvasPanMoveListener=onMove;
  canvasPanUpListener=onUp;
  window.addEventListener('pointermove',onMove,true);
  window.addEventListener('pointerup',onUp,true);
  window.addEventListener('pointercancel',onUp,true);
}
canvas.addEventListener('pointerdown',e=>{
  if(canvasPanMode){
    startCanvasPan(e);
    return;
  }
  if(!pointerCanDraw(e)) return;
  e.preventDefault();
  canvas.setPointerCapture(e.pointerId);
  drawing=true;
  jitterStrokeId=(jitterStrokeId+1)|0;
  jitterSegId=0;
  pushHistory();
  last=getPos(e);
  const val=getPaintValue();
  drawSegment(last,last,val);
  renderCurrent();
});
canvas.addEventListener('pointermove',e=>{
  if(canvasPanMode) return;
  if(!drawing) return;
  e.preventDefault();
  const p=getPos(e);
  const val=getPaintValue();
  if(currentTool==='palette'){
    drawSegment(p,p,val);
  }else{
    drawSegment(last,p,val);
  }
  last=p;
  renderCurrent();
});
function stopDrawing(e){
  if(canvasPanning && (!e || e.pointerId==null || e.pointerId===canvasPanPointerId)){
    canvasPanning=false;
    canvasPanPointerId=null;
    canvasPanStart=null;
    canvasPanBase=null;
    try{ if(canvasPanMoveListener) window.removeEventListener('pointermove',canvasPanMoveListener,true); }catch{}
    try{ if(canvasPanUpListener) window.removeEventListener('pointerup',canvasPanUpListener,true); }catch{}
    try{ if(canvasPanUpListener) window.removeEventListener('pointercancel',canvasPanUpListener,true); }catch{}
    canvasPanMoveListener=null;
    canvasPanUpListener=null;
    if(canvasPanMode){
      if(canvasViewportEl) canvasViewportEl.style.cursor='grab';
      else if(canvas) canvas.style.cursor='grab';
    }
    if(e && e.pointerId!=null){
      try{ if(canvasViewportEl) canvasViewportEl.releasePointerCapture(e.pointerId); }catch{}
      try{ canvas.releasePointerCapture(e.pointerId); }catch{}
    }
    return;
  }
  if(!drawing) return;
  drawing=false;
  try{
    if(e && e.pointerId!=null) canvas.releasePointerCapture(e.pointerId);
  }catch{}
}
if(canvasViewportEl){
  const panDown=(e)=>{
    if(!canvasPanMode) return;
    startCanvasPan(e);
    e.stopPropagation();
  };
  canvasViewportEl.addEventListener('pointerdown',panDown,{capture:true});
  canvasViewportEl.addEventListener('pointerup',stopDrawing,{capture:true});
  canvasViewportEl.addEventListener('pointercancel',stopDrawing,{capture:true});
  canvasViewportEl.addEventListener('pointerleave',stopDrawing,{capture:true});
}
canvas.addEventListener('pointerup',stopDrawing);
canvas.addEventListener('pointercancel',stopDrawing);
canvas.addEventListener('pointerleave',stopDrawing);
canvas.addEventListener('contextmenu',e=>{ e.preventDefault(); });
penBtn.addEventListener('click',()=>{ setTool('pencil'); });
pen2Btn.addEventListener('click',()=>{ setTool('pen'); });
blobbyBtn.addEventListener('click',()=>{ setTool('blobby'); });
stippleTinyBtn.addEventListener('click',()=>{ setTool('stippleTiny'); });
softLrgBtn.addEventListener('click',()=>{ setTool('softLrg'); });
eraserBtn.addEventListener('click',()=>{ setTool('eraser'); });

function clearCanvas(){
  // 清空：所有帧像素值置 0（透明）
  pushHistory();
  for(const f of frames) f.fill(0);
  renderCurrent();
}
clearBtn.addEventListener('click',clearCanvas);

// ===== GIF 导出（gifenc） =====

function exportGif(){
  // 抖动开启 => 导出 3 帧循环；抖动关闭 => 导出稳定帧 1 张
  const exportFramesRaw=jitterOnEl.checked ? [frames[0],frames[1],frames[2]] : [frames[3]];
  const transparent=toggleTransparent.checked;

  // 不透明导出：把透明像素（0）拍扁到背景色（1），这样在任何查看器里都不会“看起来没内容”
  const exportFrames=exportFramesRaw.map(f=>{
    if(transparent) return f;
    const out=new Uint8Array(f.length);
    for(let i=0;i<f.length;i++){
      const v=f[i];
      out[i]=v===0?1:v;
    }
    return out;
  });

  const palette=[];
  for(let i=0;i<=MAX_COLOR_INDEX;i++) palette[i]=hexToRGB(colorMap[i] ?? '#000000');

  const gif=GIFEncoder({ repeat: jitterOnEl.checked ? 0 : -1 });
  for(let i=0;i<exportFrames.length;i++){
    const indices=exportFrames[i];
    // frames 里存的是“调色板索引”，可以直接作为 gifenc 的 indexed bitmap 输入
    const delay=jitterOnEl.checked ? getJitterSubDelayMs(i%3) : 0;
    const options={ palette, delay };
    if(transparent) options.transparent=0;
    gif.writeFrame(indices,W,H,options);
  }
  gif.finish();
  const gifBytes=gif.bytes();
  const blob=new Blob([gifBytes],{type:'image/gif'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url;
  a.download='export.gif';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
exportGifBtn.addEventListener('click',exportGif);

const colorPage=document.getElementById('colorPage');
const container=document.querySelector('.container');
advancedBtn.addEventListener('click',()=>{
  container.classList.toggle('advanced');
  advancedBtn.classList.toggle('is-active',container.classList.contains('advanced'));
});
document.getElementById('switchColor').addEventListener('click',()=>{
  stopAnim();
  displayFrame=3;
  colorPage.style.display='flex';
  container.classList.add('color-mode');
  schemeBaseline=captureBaseline();
  syncOutlineColorsUI();
  renderCurrent();
});
document.getElementById('back').addEventListener('click',()=>{
  colorPage.style.display='none';
  container.classList.remove('color-mode');
  applyPlaybackMode();
});
document.querySelectorAll('#colorPage input[type=color]').forEach(input=>{
  const idx=Number(input.dataset.index);
  if(idx>=OUTLINE_FIRST && idx<=OUTLINE_LAST){
    input.value=outlineColorStore[idx] ?? colorMap[2];
  }else{
    input.value=colorMap[idx];
  }
  input.addEventListener('change',()=>{
    const next=input.value;
    if(idx>=OUTLINE_FIRST && idx<=OUTLINE_LAST){
      outlineColorStore[idx]=next;
      syncOutlineColorMap();
    }else{
      colorMap[idx]=next;
      if(idx===2 && !(separateOutlineEl && separateOutlineEl.checked)) syncOutlineColorMap();
      if(idx===1){ applyBackground(); }
    }
    syncPaletteButtonsColors();
    renderCurrent();
  });
});
function syncOutlineColorsUI(){
  if(!outlineColorsEl) return;
  outlineColorsEl.style.display=(separateOutlineEl && separateOutlineEl.checked)?'flex':'none';
}
if(separateOutlineEl){
  separateOutlineEl.addEventListener('change',()=>{
    syncOutlineColorsUI();
    syncOutlineColorMap();
    renderCurrent();
  });
}
const schemeSelectEl=document.getElementById('schemeSelect');
const schemeResetBtn=document.getElementById('schemeReset');
const schemeSaveBtn=document.getElementById('schemeSave');
const paletteSchemes=[
  { id:'pico8', name:'PICO-8', colors:['#000000','#1d2b53','#7e2553','#008751','#ab5236','#5f574f','#c2c3c7','#fff1e8','#ff004d','#ffa300','#ffec27','#00e436','#29adff','#83769c','#ff77a8','#ffccaa'] },
  { id:'sweetie16', name:'Sweetie 16', colors:['#1a1c2c','#5d275d','#b13e53','#ef7d57','#ffcd75','#a7f070','#38b764','#257179','#29366f','#3b5dc9','#41a6f6','#73eff7','#f4f4f4','#94b0c2','#566c86','#333c57'] },
  { id:'endesga16', name:'Endesga 16', colors:['#e4a672','#b86f50','#743f39','#3f2832','#9e2835','#e53b44','#fb922b','#ffe762','#63c64d','#327345','#193d3f','#4f6781','#afbfd2','#ffffff','#2ce8f4','#0484d1'] },
  { id:'db16', name:'DawnBringer 16', colors:['#140c1c','#442434','#30346d','#4e4a4e','#854c30','#346524','#d04648','#757161','#597dce','#d27d2c','#8595a1','#6daa2c','#d2aa99','#6dc2ca','#dad45e','#deeed6'] },
  { id:'enos16', name:'ENOS16', colors:['#fafafa','#d4d4d4','#9d9d9d','#4b4b4b','#f9d381','#eaaf4d','#f9938a','#e75952','#9ad1f9','#58aeee','#8deda7','#44c55b','#c3a7e1','#9569c8','#bab5aa','#948e82'] },
];
const CUSTOM_SCHEMES_STORAGE_KEY='wpaint.paletteSchemes.v1';
function normalizeScheme(raw){
  if(!raw || typeof raw!=='object') return null;
  const id=String(raw.id||'').trim();
  const name=String(raw.name||'').trim();
  const colors=raw.colors;
  if(!id || !name || !Array.isArray(colors) || colors.length!==BASE_COLOR_COUNT) return null;
  const normalizedColors=colors.map(c=>String(c||'').trim()).filter(Boolean);
  if(normalizedColors.length!==BASE_COLOR_COUNT) return null;
  const outlineColorsRaw=raw.outlineColors;
  let normalizedOutlineColors=null;
  if(Array.isArray(outlineColorsRaw) && outlineColorsRaw.length===(OUTLINE_LAST-OUTLINE_FIRST+1)){
    const tmp=outlineColorsRaw.map(c=>String(c||'').trim()).filter(Boolean);
    if(tmp.length===(OUTLINE_LAST-OUTLINE_FIRST+1)) normalizedOutlineColors=tmp;
  }
  const separateOutline=(raw.separateOutline===true || raw.separateOutline===false) ? raw.separateOutline : null;
  const out={ id, name, colors: normalizedColors };
  if(normalizedOutlineColors) out.outlineColors=normalizedOutlineColors;
  if(separateOutline!==null) out.separateOutline=separateOutline;
  return out;
}
function loadCustomPaletteSchemes(){
  try{
    const raw=localStorage.getItem(CUSTOM_SCHEMES_STORAGE_KEY);
    if(!raw) return [];
    const parsed=JSON.parse(raw);
    if(!Array.isArray(parsed)) return [];
    return parsed.map(normalizeScheme).filter(Boolean);
  }catch{
    return [];
  }
}
function saveCustomPaletteSchemes(list){
  try{
    localStorage.setItem(CUSTOM_SCHEMES_STORAGE_KEY,JSON.stringify(list));
  }catch{}
}
let customPaletteSchemes=loadCustomPaletteSchemes();
for(const s of customPaletteSchemes){
  if(!paletteSchemes.some(x=>x.id===s.id)) paletteSchemes.push(s);
}
let schemeBaseline=null;
function getCurrentPalette16(){
  const colors=[];
  for(let i=1;i<=BASE_COLOR_COUNT;i++) colors.push(colorMap[i]);
  return colors;
}
function getOutlineColors5(){
  const colors=[];
  for(let i=OUTLINE_FIRST;i<=OUTLINE_LAST;i++) colors.push(outlineColorStore[i] ?? colorMap[2]);
  return colors;
}
function setOutlineColors5(colors){
  if(!Array.isArray(colors) || colors.length!==(OUTLINE_LAST-OUTLINE_FIRST+1)) return;
  for(let i=OUTLINE_FIRST;i<=OUTLINE_LAST;i++){
    const c=colors[i-OUTLINE_FIRST];
    if(!c) continue;
    outlineColorStore[i]=c;
    const input=document.querySelector(`#colorPage input[type=color][data-index="${i}"]`);
    if(input) input.value=c;
  }
}
function setPalette16(colors){
  for(let i=1;i<=BASE_COLOR_COUNT;i++){
    const c=colors[i-1];
    if(!c) continue;
    colorMap[i]=c;
    const input=document.querySelector(`#colorPage input[type=color][data-index="${i}"]`);
    if(input) input.value=c;
  }
}
function captureBaseline(){
  return {
    colors: getCurrentPalette16(),
    outlineColors: getOutlineColors5(),
    separateOutline: Boolean(separateOutlineEl && separateOutlineEl.checked),
  };
}
function applyBaseline(baseline){
  if(!baseline) return;
  setPalette16(baseline.colors);
  setOutlineColors5(baseline.outlineColors);
  if(separateOutlineEl) separateOutlineEl.checked=Boolean(baseline.separateOutline);
  syncOutlineColorsUI();
  syncOutlineColorMap();
  applyBackground();
  syncPaletteButtonsColors();
  renderCurrent();
}
function appendSchemeOption(scheme){
  if(!schemeSelectEl) return;
  const opt=document.createElement('option');
  opt.value=scheme.id;
  opt.textContent=scheme.name;
  schemeSelectEl.appendChild(opt);
}
function applyPaletteScheme(colors){
  for(let i=1;i<=BASE_COLOR_COUNT;i++){
    colorMap[i]=colors[i-1];
    const input=document.querySelector(`#colorPage input[type=color][data-index="${i}"]`);
    if(input) input.value=colorMap[i];
  }
  syncOutlineColorMap();
  applyBackground();
  syncPaletteButtonsColors();
  renderCurrent();
}
if(schemeSelectEl){
  const keepOpt=document.createElement('option');
  keepOpt.value='';
  keepOpt.textContent='配色方案';
  schemeSelectEl.appendChild(keepOpt);
  for(const s of paletteSchemes){
    appendSchemeOption(s);
  }
  schemeSelectEl.value='';
  schemeSelectEl.addEventListener('change',()=>{
    const id=String(schemeSelectEl.value||'');
    const scheme=paletteSchemes.find(s=>s.id===id);
    if(!scheme) return;
    applyPaletteScheme(scheme.colors);
    if(scheme && scheme.separateOutline!=null && separateOutlineEl){
      separateOutlineEl.checked=Boolean(scheme.separateOutline);
      syncOutlineColorsUI();
    }
    if(scheme && Array.isArray(scheme.outlineColors)) setOutlineColors5(scheme.outlineColors);
    syncOutlineColorMap();
    applyBackground();
    syncPaletteButtonsColors();
    renderCurrent();
    schemeBaseline=captureBaseline();
  });
}
if(schemeResetBtn){
  schemeResetBtn.addEventListener('click',()=>{
    applyBaseline(schemeBaseline);
  });
}
if(schemeSaveBtn){
  schemeSaveBtn.addEventListener('click',()=>{
    const colors=getCurrentPalette16();
    const id=`custom-${Date.now().toString(36)}-${Math.random().toString(36).slice(2,8)}`;
    const name=`自定义 ${customPaletteSchemes.length+1}`;
    const scheme={
      id,
      name,
      colors: colors.slice(),
      outlineColors: getOutlineColors5(),
      separateOutline: Boolean(separateOutlineEl && separateOutlineEl.checked),
    };
    paletteSchemes.push(scheme);
    customPaletteSchemes.push(scheme);
    saveCustomPaletteSchemes(customPaletteSchemes);
    appendSchemeOption(scheme);
    if(schemeSelectEl) schemeSelectEl.value=id;
    schemeBaseline=captureBaseline();
  });
}
const checkerboard=document.getElementById('checkerboard');
const toggleTransparent=document.getElementById('toggleTransparent');
const canvasZoomRangeEl=document.getElementById('canvasZoom');
const canvasZoomValueEl=document.getElementById('canvasZoomValue');
const zoomInEl=document.getElementById('zoomIn');
const zoomOutEl=document.getElementById('zoomOut');
const zoomResetEl=document.getElementById('zoomReset');
const canvasPanModeEl=document.getElementById('canvasPanMode');
const jitterOnEl=document.getElementById('jitterOn');
const jitter=document.getElementById('jitter');
const jitterValue=document.getElementById('jitterValue');
const jitterDelayEl=document.getElementById('jitterDelay');
const jitterControlsEl=document.getElementById('jitterControls');
const eraserControlsEl=document.getElementById('eraserControls');
const eraseOnlyOutlineEl=document.getElementById('eraseOnlyOutline');
const eraseOnlyEraserEl=document.getElementById('eraseOnlyEraser');
let timelinePlaying=false;
let jitterSubDelay=120;
let canvasViewScale=1;
let canvasViewPanX=0;
let canvasViewPanY=0;
let canvasPanMode=false;
let canvasPanning=false;
let canvasPanPointerId=null;
let canvasPanStart=null;
let canvasPanBase=null;
let toolBeforePan=null;
function applyCanvasViewTransform(){
  const safeScale=(Number(canvasViewScale)||1)||1;
  const t=`translate(${canvasViewPanX}px,${canvasViewPanY}px) scale(${safeScale})`;
  if(canvas) canvas.style.transform=t;
  if(canvasBgEl) canvasBgEl.style.transform=t;
  updateCheckerboardScale();
}
function updateCheckerboardScale(){
  if(!checkerboard) return;
  if(customBgUrl) return;
  const px=Math.max(2,Math.round(16*canvasViewScale));
  checkerboard.style.backgroundSize=`${px}px ${px}px`;
  checkerboard.style.backgroundPosition=`0 0, ${Math.round(px/2)}px ${Math.round(px/2)}px`;
}
function setCanvasViewScale(scale){
  const prev=canvasViewScale;
  const next=Math.max(0.5,Math.min(3,Number(scale)||1));
  if(next!==prev){
    const anchorScreenX=W/2;
    const anchorScreenY=H/2;
    const anchorContentX=(anchorScreenX-canvasViewPanX)/prev;
    const anchorContentY=(anchorScreenY-canvasViewPanY)/prev;
    canvasViewScale=next;
    canvasViewPanX=Math.round(anchorScreenX-anchorContentX*next);
    canvasViewPanY=Math.round(anchorScreenY-anchorContentY*next);
    clampCanvasPan();
  }else{
    canvasViewScale=next;
  }
  if(canvasZoomRangeEl) canvasZoomRangeEl.value=String(Math.round(next*100));
  if(canvasZoomValueEl) canvasZoomValueEl.textContent=`${Math.round(next*100)}%`;
  applyCanvasViewTransform();
}
function clampCanvasPan(){
  const scaledW=W*canvasViewScale;
  const scaledH=H*canvasViewScale;
  const minX=Math.min(0,W-scaledW);
  const maxX=Math.max(0,W-scaledW);
  const minY=Math.min(0,H-scaledH);
  const maxY=Math.max(0,H-scaledH);
  canvasViewPanX=Math.max(minX,Math.min(maxX,canvasViewPanX));
  canvasViewPanY=Math.max(minY,Math.min(maxY,canvasViewPanY));
}
function setCanvasPanMode(on){
  const wasOn=canvasPanMode;
  canvasPanMode=Boolean(on);
  if(canvasPanModeEl) canvasPanModeEl.checked=canvasPanMode;
  if(canvasViewportEl) canvasViewportEl.style.cursor=canvasPanMode?'grab':'crosshair';
  else if(canvas) canvas.style.cursor=canvasPanMode?'grab':'crosshair';
  if(!wasOn && canvasPanMode){
    toolBeforePan=currentTool;
    for(const el of document.querySelectorAll('.tool-btn.is-active,.action-btn.is-active,.palette-btn.is-active,.anim-frame-btn.is-active')){
      el.classList.remove('is-active');
    }
  }else if(wasOn && !canvasPanMode){
    const restore=toolBeforePan;
    toolBeforePan=null;
    if(restore) setTool(restore);
  }
}
function openZoomMenu(){
  if(!zoomMenuEl || !zoomBtnEl) return;
  zoomMenuEl.classList.add('is-open');
  zoomBtnEl.classList.add('is-active');
  zoomBtnEl.setAttribute('aria-expanded','true');
  applyStageScale();
}
function closeZoomMenu(){
  if(!zoomMenuEl || !zoomBtnEl) return;
  zoomMenuEl.classList.remove('is-open');
  zoomBtnEl.classList.remove('is-active');
  zoomBtnEl.setAttribute('aria-expanded','false');
  applyStageScale();
}
function toggleZoomMenu(){
  if(!zoomMenuEl) return;
  if(zoomMenuEl.classList.contains('is-open')) closeZoomMenu();
  else openZoomMenu();
}
if(zoomBtnEl){
  zoomBtnEl.addEventListener('click',(e)=>{
    e.preventDefault();
    toggleZoomMenu();
  });
}
window.addEventListener('pointerdown',(e)=>{
  if(!zoomMenuEl || !zoomBtnEl) return;
  if(!zoomMenuEl.classList.contains('is-open')) return;
  const target=e.target;
  if(zoomMenuEl.contains(target) || zoomBtnEl.contains(target)) return;
  closeZoomMenu();
},{capture:true});
if(canvasZoomRangeEl){
  const onZoomInput=()=>{
    const v=Math.max(50,Math.min(300,Number(canvasZoomRangeEl.value)||100));
    setCanvasViewScale(v/100);
  };
  canvasZoomRangeEl.addEventListener('input',onZoomInput);
  canvasZoomRangeEl.addEventListener('change',onZoomInput);
}
if(zoomInEl){
  zoomInEl.addEventListener('click',()=>{
    setCanvasViewScale((Math.round(canvasViewScale*100)+10)/100);
  });
}
if(zoomOutEl){
  zoomOutEl.addEventListener('click',()=>{
    setCanvasViewScale((Math.round(canvasViewScale*100)-10)/100);
  });
}
if(zoomResetEl){
  zoomResetEl.addEventListener('click',()=>{
    setCanvasViewScale(1);
  });
}
if(canvasPanModeEl){
  canvasPanModeEl.addEventListener('change',()=>{
    setCanvasPanMode(Boolean(canvasPanModeEl.checked));
  });
}
setCanvasViewScale(1);
setCanvasPanMode(false);
function getJitterSubDelayMs(i){
  return Math.max(20,Number(jitterSubDelay)||120);
}
function updateJitterSubDelays(){
  const v=Math.max(20,Number(jitterDelayEl && jitterDelayEl.value)||120);
  if(jitterDelayEl) jitterDelayEl.value=String(v);
  jitterSubDelay=v;
  if(container.classList.contains('color-mode')) return;
  if(timelinePlaying) return;
  if(jitterOnEl && jitterOnEl.checked){
    stopAnim();
    if(displayFrame===3) displayFrame=0;
    renderCurrent();
    startAnim();
  }
}
updateJitterSubDelays();
if(jitterDelayEl) jitterDelayEl.addEventListener('change',updateJitterSubDelays);
if(eraseOnlyOutlineEl && eraseOnlyEraserEl){
  eraseOnlyOutlineEl.addEventListener('change',()=>{
    if(eraseOnlyOutlineEl.checked) eraseOnlyEraserEl.checked=false;
  });
  eraseOnlyEraserEl.addEventListener('change',()=>{
    if(eraseOnlyEraserEl.checked) eraseOnlyOutlineEl.checked=false;
  });
}
function updateJitter(){
  jitterLevel=Number(jitter.value)||0;
  jitterValue.textContent=String(jitterLevel);
}
updateJitter();
jitter.addEventListener('input',updateJitter);
jitterOnEl.addEventListener('change',()=>{
  if(container.classList.contains('color-mode')){
    displayFrame=jitterOnEl.checked?0:3;
    return;
  }
  applyPlaybackMode();
});
sizeEl.addEventListener('input',()=>{
  const v=Math.max(1,Math.min(31,Number(sizeEl.value)||1));
  if(!toolSettings[currentTool]) toolSettings[currentTool]={ size:1 };
  toolSettings[currentTool].size=v;
  sizeValueEl.textContent=String(v);
});
function fileToImage(file){
  return new Promise((resolve,reject)=>{
    const url=URL.createObjectURL(file);
    const img=new Image();
    img.onload=()=>{
      URL.revokeObjectURL(url);
      resolve(img);
    };
    img.onerror=()=>{
      URL.revokeObjectURL(url);
      reject(new Error('image load failed'));
    };
    img.src=url;
  });
}
const patternRenderCanvas=document.createElement('canvas');
patternRenderCanvas.width=PATTERN_W;
patternRenderCanvas.height=PATTERN_H;
const patternRenderCtx=patternRenderCanvas.getContext('2d');
patternRenderCtx.imageSmoothingEnabled=false;
function renderMaskToCanvas(mask,w,h,ctx){
  const img=ctx.createImageData(w,h);
  const data=img.data;
  for(let i=0;i<mask.length;i++){
    const o=i*4;
    if(mask[i]){
      data[o]=0; data[o+1]=0; data[o+2]=0; data[o+3]=255;
    }else{
      data[o]=0; data[o+1]=0; data[o+2]=0; data[o+3]=0;
    }
  }
  ctx.putImageData(img,0,0);
}
function renderDefaultThumb(){
  const w=patternThumbCanvas.width;
  const h=patternThumbCanvas.height;
  const img=patternThumbCtx.createImageData(w,h);
  const data=img.data;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const on=((x>>2)^(y>>2))&1;
      const o=(y*w+x)*4;
      const v=on?40:220;
      data[o]=v; data[o+1]=v; data[o+2]=v; data[o+3]=255;
    }
  }
  patternThumbCtx.putImageData(img,0,0);
}
function getActiveMask32(){
  if(activePatternId==='default') return null;
  const p=patterns.find(x=>x.id===activePatternId);
  return (p && p.mask) ? p.mask : null;
}
function updatePatternSelectUI(){
  if(activePatternId==='default'){
    patternSelectLabelEl.textContent='默认图案';
    renderDefaultThumb();
  }else{
    patternSelectLabelEl.textContent='';
    const m=getActiveMask32();
    if(m){
      patternRenderCtx.clearRect(0,0,PATTERN_W,PATTERN_H);
      renderMaskToCanvas(m,PATTERN_W,PATTERN_H,patternRenderCtx);
      patternThumbCtx.clearRect(0,0,patternThumbCanvas.width,patternThumbCanvas.height);
      patternThumbCtx.drawImage(patternRenderCanvas,0,0,patternThumbCanvas.width,patternThumbCanvas.height);
    }else{
      renderDefaultThumb();
    }
  }
  for(const btn of patternListEl.querySelectorAll('.pattern-item')){
    btn.classList.toggle('is-active',btn.dataset.id===activePatternId);
  }
}
function rebuildPatternList(){
  patternListEl.innerHTML='';
  for(const p of patterns){
    const btn=document.createElement('button');
    btn.type='button';
    btn.className='pattern-item';
    btn.dataset.id=p.id;
    if(p.id==='default'){
      btn.innerHTML=`<span class="label">默认</span>`;
    }else{
      const c=document.createElement('canvas');
      c.width=PATTERN_W;
      c.height=PATTERN_H;
      const cctx=c.getContext('2d');
      cctx.imageSmoothingEnabled=false;
      renderMaskToCanvas(p.mask,PATTERN_W,PATTERN_H,cctx);
      btn.appendChild(c);
    }
    btn.addEventListener('click',()=>{
      activePatternId=p.id;
      updatePatternSelectUI();
      closePatternPopover();
    });
    patternListEl.appendChild(btn);
  }
  updatePatternSelectUI();
}
function openPatternPopover(){
  patternPopoverEl.classList.add('is-open');
  patternSelectBtn.setAttribute('aria-expanded','true');
}
function closePatternPopover(){
  patternPopoverEl.classList.remove('is-open');
  patternSelectBtn.setAttribute('aria-expanded','false');
}
patternSelectBtn.addEventListener('click',()=>{
  if(patternPopoverEl.classList.contains('is-open')) closePatternPopover();
  else openPatternPopover();
});
document.addEventListener('mousedown',(e)=>{
  if(!patternPopoverEl.classList.contains('is-open')) return;
  if(patternPickerEl && patternPickerEl.contains(e.target)) return;
  closePatternPopover();
});
const fileMenuToggleEl=document.getElementById('fileMenuToggle');
const fileMenuEl=document.getElementById('fileMenu');
function openFileMenu(){
  fileMenuEl.classList.add('is-open');
  fileMenuToggleEl.setAttribute('aria-expanded','true');
}
function closeFileMenu(){
  fileMenuEl.classList.remove('is-open');
  fileMenuToggleEl.setAttribute('aria-expanded','false');
}
fileMenuToggleEl.addEventListener('click',()=>{
  if(fileMenuEl.classList.contains('is-open')) closeFileMenu();
  else openFileMenu();
});
document.addEventListener('mousedown',(e)=>{
  if(!fileMenuEl.classList.contains('is-open')) return;
  if(fileMenuToggleEl && fileMenuToggleEl.contains(e.target)) return;
  if(fileMenuEl && fileMenuEl.contains(e.target)) return;
  closeFileMenu();
});
fileMenuEl.addEventListener('click',(e)=>{
  if(e.target.closest('button')) closeFileMenu();
});
const aboutBtnEl=document.getElementById('aboutBtn');
const aboutModalEl=document.getElementById('aboutModal');
const aboutCloseEl=document.getElementById('aboutClose');
const modalPositions=new Map();
function getModalCard(modalEl){
  return modalEl ? modalEl.querySelector('.modal-card') : null;
}
function getModalHead(modalEl){
  return modalEl ? modalEl.querySelector('.modal-head') : null;
}
function clamp(v,min,max){
  return Math.max(min,Math.min(max,v));
}
function centerModal(modalEl){
  const card=getModalCard(modalEl);
  if(!modalEl || !card) return;
  card.classList.add('is-draggable');
  const key=modalEl.id || 'modal';
  if(modalPositions.has(key)){
    const pos=modalPositions.get(key);
    card.style.left=`${pos.left}px`;
    card.style.top=`${pos.top}px`;
    return;
  }
  const mw=modalEl.clientWidth;
  const mh=modalEl.clientHeight;
  const cw=card.offsetWidth;
  const ch=card.offsetHeight;
  const left=Math.max(8,Math.round((mw-cw)/2));
  const top=Math.max(8,Math.round((mh-ch)/2));
  card.style.left=`${left}px`;
  card.style.top=`${top}px`;
  modalPositions.set(key,{ left, top });
}
function openModal(modalEl){
  if(!modalEl) return;
  modalEl.classList.add('is-open');
  window.requestAnimationFrame(()=>centerModal(modalEl));
}
function closeModal(modalEl){
  if(!modalEl) return;
  modalEl.classList.remove('is-open');
}
function makeModalDraggable(modalEl){
  const card=getModalCard(modalEl);
  const head=getModalHead(modalEl);
  if(!modalEl || !card || !head) return;
  let dragging=false;
  let startX=0, startY=0, startLeft=0, startTop=0;
  head.addEventListener('pointerdown',(e)=>{
    if(e.button!==0) return;
    if(!modalEl.classList.contains('is-open')) return;
    if(e.target && e.target.closest && e.target.closest('button,input,select,textarea,a')) return;
    dragging=true;
    const rect=modalEl.getBoundingClientRect();
    const cardRect=card.getBoundingClientRect();
    startX=e.clientX;
    startY=e.clientY;
    startLeft=cardRect.left-rect.left;
    startTop=cardRect.top-rect.top;
    head.setPointerCapture(e.pointerId);
    e.preventDefault();
  });
  head.addEventListener('pointermove',(e)=>{
    if(!dragging) return;
    const dx=e.clientX-startX;
    const dy=e.clientY-startY;
    const mw=modalEl.clientWidth;
    const mh=modalEl.clientHeight;
    const cw=card.offsetWidth;
    const ch=card.offsetHeight;
    const left=clamp(Math.round(startLeft+dx),8,Math.max(8,mw-cw-8));
    const top=clamp(Math.round(startTop+dy),8,Math.max(8,mh-ch-8));
    card.style.left=`${left}px`;
    card.style.top=`${top}px`;
    const key=modalEl.id || 'modal';
    modalPositions.set(key,{ left, top });
  });
  function endDrag(e){
    if(!dragging) return;
    dragging=false;
    try{ head.releasePointerCapture(e.pointerId); }catch{}
  }
  head.addEventListener('pointerup',endDrag);
  head.addEventListener('pointercancel',endDrag);
}
makeModalDraggable(aboutModalEl);
function openAbout(){
  if(!aboutModalEl) return;
  openModal(aboutModalEl);
}
function closeAbout(){
  if(!aboutModalEl) return;
  closeModal(aboutModalEl);
}
if(aboutBtnEl) aboutBtnEl.addEventListener('click',openAbout);
if(aboutCloseEl) aboutCloseEl.addEventListener('click',closeAbout);
if(aboutModalEl){
  aboutModalEl.addEventListener('mousedown',(e)=>{
    if(e.target===aboutModalEl) closeAbout();
  });
}
window.addEventListener('keydown',(e)=>{
  if(e.key==='Escape' && aboutModalEl && aboutModalEl.classList.contains('is-open')) closeAbout();
});
const animBtnEl=document.getElementById('animBtn');
const animModalEl=document.getElementById('animModal');
const animCloseEl=document.getElementById('animClose');
const animFrameListEl=document.getElementById('animFrameList');
const animNewFrameEl=document.getElementById('animNewFrame');
const animDeleteFrameEl=document.getElementById('animDeleteFrame');
const animMultiSelectEl=document.getElementById('animMultiSelect');
const animDelayEl=document.getElementById('animDelay');
const animPlayEl=document.getElementById('animPlay');
const animPlayCloseEl=document.getElementById('animPlayClose');
const animApplyAllDelayEl=document.getElementById('animApplyAllDelay');
const animExportGifEl=document.getElementById('animExportGif');
let animMultiSelectMode=false;
let timeline=[{ frames:[frames[0],frames[1],frames[2],frames[3]], delay:360 }];
let timelineIndex=0;
let timelineToken=0;
let timelineAnchor=0;
let timelineSelected=new Set([0]);
let animJustDraggedUntil=0;
let animDrag=null;
makeModalDraggable(animModalEl);
function applyTimelineFrame(i){
  const t=timeline[i];
  if(!t) return;
  for(let fi=0;fi<4;fi++){
    frames[fi]=t.frames[fi];
  }
}
function moveTimelineFrameInsert(from,insertIndex){
  const len=timeline.length;
  const a=from|0;
  const b=insertIndex|0;
  if(a<0 || a>=len) return;
  const nextLen=len-1;
  const finalIndex=clamp(b,0,nextLen);
  if(finalIndex===a) return;
  const [item]=timeline.splice(a,1);
  timeline.splice(finalIndex,0,item);
  const remap=(idx)=>{
    if(idx===a) return finalIndex;
    if(a<finalIndex && a<idx && idx<=finalIndex) return idx-1;
    if(finalIndex<a && finalIndex<=idx && idx<a) return idx+1;
    return idx;
  };
  timelineIndex=remap(timelineIndex);
  timelineAnchor=remap(timelineAnchor);
  const nextSelected=new Set();
  for(const s of timelineSelected){
    nextSelected.add(remap(s));
  }
  timelineSelected=nextSelected;
}
function setTimelineIndex(i){
  const next=Math.max(0,Math.min(timeline.length-1,i|0));
  timelineIndex=next;
  applyTimelineFrame(timelineIndex);
  if(jitterOnEl && jitterOnEl.checked && !timelinePlaying){
    applyPlaybackMode();
  }else{
    stopAnim();
    displayFrame=3;
    renderCurrent();
  }
  syncAnimUI();
}
function cloneTimelineFrame(src){
  return { frames: src.frames.map(f=>new Uint8Array(f)), delay: src.delay|0 };
}
function rebuildAnimFrameList(){
  if(!animFrameListEl) return;
  animFrameListEl.innerHTML='';
  for(let i=0;i<timeline.length;i++){
    const btn=document.createElement('button');
    btn.type='button';
    btn.dataset.index=String(i);
    const active=i===timelineIndex;
    const selected=timelineSelected.has(i);
    btn.className='anim-frame-btn'+(active?' is-active':'')+(selected?' is-selected':'');
    btn.textContent=String(i+1);
    btn.title=`第 ${i+1} 帧（${Math.max(30,timeline[i]?.delay|0)}ms）`;
    btn.addEventListener('click',(e)=>{
      if(Date.now()<animJustDraggedUntil) return;
      if(timelinePlaying) return;
      const isMac=navigator.platform.toLowerCase().includes('mac');
      const multiKey=isMac ? e.metaKey : e.ctrlKey;
      if(e.shiftKey){
        const a=clamp(timelineAnchor,0,timeline.length-1);
        const b=i;
        const lo=Math.min(a,b), hi=Math.max(a,b);
        const next=new Set();
        for(let k=lo;k<=hi;k++) next.add(k);
        timelineSelected=next;
      }else if(animMultiSelectMode || multiKey){
        const next=new Set(timelineSelected);
        if(next.has(i)) next.delete(i);
        else next.add(i);
        if(next.size===0) next.add(i);
        timelineSelected=next;
        timelineAnchor=i;
      }else{
        timelineAnchor=i;
        timelineSelected=new Set([i]);
      }
      setTimelineIndex(i);
    });
    animFrameListEl.appendChild(btn);
  }
}
function syncAnimUI(){
  rebuildAnimFrameList();
  const selected=[...timelineSelected].filter(i=>i>=0 && i<timeline.length);
  const delays=selected.map(i=>Math.max(30,timeline[i]?.delay|0));
  const uniform=delays.length>0 && delays.every(x=>x===delays[0]);
  if(animDelayEl){
    if(delays.length===0){
      animDelayEl.value='';
    }else if(uniform){
      animDelayEl.value=String(delays[0]);
      animDelayEl.placeholder='';
    }else{
      animDelayEl.value='';
      animDelayEl.placeholder='—';
    }
  }
  const disable=timelinePlaying;
  if(animNewFrameEl) animNewFrameEl.disabled=disable;
  if(animDeleteFrameEl) animDeleteFrameEl.disabled=disable || timeline.length<=1 || timelineSelected.size===0;
  if(animDelayEl) animDelayEl.disabled=disable;
  if(animPlayEl) animPlayEl.textContent=timelinePlaying?'停止':'播放';
  if(animPlayCloseEl) animPlayCloseEl.disabled=disable;
  if(animApplyAllDelayEl) animApplyAllDelayEl.disabled=disable;
  if(animExportGifEl) animExportGifEl.disabled=disable;
  if(animMultiSelectEl){
    animMultiSelectEl.disabled=disable;
    animMultiSelectEl.classList.toggle('is-active',animMultiSelectMode);
  }
}
function openAnim(){
  if(!animModalEl) return;
  stopTimelinePlayback();
  stopAnim();
  displayFrame=3;
  renderCurrent();
  openModal(animModalEl);
  if(timelineSelected.size===0) timelineSelected=new Set([timelineIndex]);
  timelineAnchor=timelineIndex;
  syncAnimUI();
}
function closeAnim(options){
  if(!animModalEl) return;
  const stopPlayback=options?.stopPlayback!==false;
  if(stopPlayback){
    stopTimelinePlayback();
    closeModal(animModalEl);
    applyPlaybackMode();
  }else{
    closeModal(animModalEl);
  }
}
function stopTimelinePlayback(){
  timelinePlaying=false;
  timelineToken++;
  syncAnimUI();
}
function startTimelinePlayback(){
  if(timelinePlaying) return;
  stopAnim();
  timelinePlaying=true;
  const token=++timelineToken;
  syncAnimUI();
  const playCel=()=>{
    if(!timelinePlaying || token!==timelineToken) return;
    const cel=timeline[timelineIndex];
    if(!cel){ stopTimelinePlayback(); return; }
    let remaining=Math.max(30,cel.delay|0);
    let sub=0;
    const tick=()=>{
      if(!timelinePlaying || token!==timelineToken) return;
      displayFrame=sub;
      renderCurrent();
      const base=getJitterSubDelayMs(sub);
      const wait=Math.min(base,remaining);
      remaining-=wait;
      if(remaining>0){
        sub=(sub+1)%3;
        window.setTimeout(tick,wait);
      }else{
        timelineIndex=(timelineIndex+1)%timeline.length;
        applyTimelineFrame(timelineIndex);
        syncAnimUI();
        window.setTimeout(playCel,wait);
      }
    };
    tick();
  };
  playCel();
}
if(animBtnEl) animBtnEl.addEventListener('click',openAnim);
if(animCloseEl) animCloseEl.addEventListener('click',()=>closeAnim());
if(animModalEl){
  animModalEl.addEventListener('mousedown',(e)=>{
    if(e.target===animModalEl) closeAnim();
  });
}
window.addEventListener('keydown',(e)=>{
  if(e.key==='Escape' && animModalEl && animModalEl.classList.contains('is-open')) closeAnim();
});
if(animFrameListEl){
  function animGetInsertIndex(clientX,clientY){
    const buttons=[...animFrameListEl.querySelectorAll('.anim-frame-btn')];
    if(buttons.length===0) return 0;
    const items=buttons.map((el,i)=>{
      const r=el.getBoundingClientRect();
      return { el, i, left:r.left, right:r.right, top:r.top, bottom:r.bottom, cx:r.left+r.width/2, cy:r.top+r.height/2 };
    }).sort((a,b)=> (a.top-b.top) || (a.left-b.left) || (a.i-b.i));
    const rows=[];
    const rowTol=10;
    for(const it of items){
      const last=rows[rows.length-1];
      if(!last || Math.abs(it.top-last.top)>rowTol){
        rows.push({ top: it.top, bottom: it.bottom, items:[it] });
      }else{
        last.items.push(it);
        last.bottom=Math.max(last.bottom,it.bottom);
        last.top=Math.min(last.top,it.top);
      }
    }
    for(const row of rows){
      row.items.sort((a,b)=>a.left-b.left);
    }
    let rowIndex=0;
    let bestRowDist=Infinity;
    for(let r=0;r<rows.length;r++){
      const row=rows[r];
      const cy=(row.top+row.bottom)/2;
      const dy=Math.abs(clientY-cy);
      if(dy<bestRowDist){
        bestRowDist=dy;
        rowIndex=r;
      }
    }
    const row=rows[rowIndex];
    let within=0;
    if(row.items.length>0){
      let pos=row.items.length;
      for(let k=0;k<row.items.length;k++){
        const it=row.items[k];
        const before=clientX < it.cx;
        if(before){ pos=k; break; }
      }
      within=clamp(pos,0,row.items.length);
    }
    let base=0;
    for(let r=0;r<rowIndex;r++) base+=rows[r].items.length;
    return clamp(base+within,0,buttons.length);
  }
  function animPlacePlaceholder(index){
    if(!animDrag || !animDrag.placeholderEl) return;
    const placeholder=animDrag.placeholderEl;
    const buttons=[...animFrameListEl.querySelectorAll('.anim-frame-btn')];
    if(index>=buttons.length) animFrameListEl.appendChild(placeholder);
    else animFrameListEl.insertBefore(placeholder,buttons[index]);
  }
  function animStartDrag(e,btn,fromIndex){
    if(timelinePlaying) return;
    if(animDrag && animDrag.active) return;
    const rect=btn.getBoundingClientRect();
    const placeholder=document.createElement('div');
    placeholder.className='anim-frame-placeholder';
    btn.parentNode.insertBefore(placeholder,btn);
    const ghost=btn.cloneNode(true);
    ghost.classList.add('is-dragging');
    ghost.style.position='fixed';
    ghost.style.left=`${rect.left}px`;
    ghost.style.top=`${rect.top}px`;
    ghost.style.width=`${rect.width}px`;
    ghost.style.height=`${rect.height}px`;
    ghost.style.zIndex='10000';
    ghost.style.pointerEvents='none';
    ghost.style.margin='0';
    document.body.appendChild(ghost);
    btn.remove();
    animDrag={
      pointerId: e.pointerId,
      fromIndex,
      placeholderEl: placeholder,
      ghostEl: ghost,
      offsetX: e.clientX-rect.left,
      offsetY: e.clientY-rect.top,
      active: true,
    };
    animFrameListEl.setPointerCapture(e.pointerId);
    animJustDraggedUntil=Date.now()+250;
    e.preventDefault();
  }
  function animFinishDrag(e,cancelled){
    if(!animDrag || animDrag.pointerId!==e.pointerId) return;
    const fromIndex=animDrag.fromIndex;
    const placeholder=animDrag.placeholderEl;
    const ghost=animDrag.ghostEl;
    let insertIndex=0;
    for(const child of animFrameListEl.children){
      if(child===placeholder) break;
      if(child.classList && child.classList.contains('anim-frame-btn')) insertIndex++;
    }
    animDrag=null;
    try{ animFrameListEl.releasePointerCapture(e.pointerId); }catch{}
    if(ghost && ghost.parentNode) ghost.parentNode.removeChild(ghost);
    if(placeholder && placeholder.parentNode) placeholder.parentNode.removeChild(placeholder);
    if(!cancelled){
      moveTimelineFrameInsert(fromIndex,insertIndex);
    }
    syncAnimUI();
  }
  animFrameListEl.addEventListener('pointerdown',(e)=>{
    if(timelinePlaying) return;
    const btn=e.target.closest('.anim-frame-btn');
    if(!btn) return;
    const idx=Number(btn.dataset.index);
    if(!Number.isFinite(idx)) return;
    const pointerId=e.pointerId;
    const startX=e.clientX;
    const startY=e.clientY;
    let started=false;
    let timerId=0;
    if(e.pointerType==='touch'){
      timerId=window.setTimeout(()=>{
        if(started) return;
        started=true;
        animStartDrag(e,btn,idx);
      },220);
    }
    function onMove(ev){
      if(ev.pointerId!==pointerId) return;
      if(timelinePlaying) return;
      if(!started){
        const dx=ev.clientX-startX;
        const dy=ev.clientY-startY;
        if(Math.hypot(dx,dy)>=6){
          started=true;
          if(timerId) window.clearTimeout(timerId);
          animStartDrag(ev,btn,idx);
        }
        return;
      }
      if(!animDrag || animDrag.pointerId!==pointerId) return;
      const ghost=animDrag.ghostEl;
      if(ghost){
        ghost.style.left=`${ev.clientX-animDrag.offsetX}px`;
        ghost.style.top=`${ev.clientY-animDrag.offsetY}px`;
      }
      animPlacePlaceholder(animGetInsertIndex(ev.clientX,ev.clientY));
    }
    function cleanup(){
      if(timerId) window.clearTimeout(timerId);
      window.removeEventListener('pointermove',onMove,true);
      window.removeEventListener('pointerup',onUp,true);
      window.removeEventListener('pointercancel',onCancel,true);
    }
    function onUp(ev){
      if(ev.pointerId!==pointerId) return;
      cleanup();
      if(started) animFinishDrag(ev,false);
    }
    function onCancel(ev){
      if(ev.pointerId!==pointerId) return;
      cleanup();
      if(started) animFinishDrag(ev,true);
    }
    window.addEventListener('pointermove',onMove,true);
    window.addEventListener('pointerup',onUp,true);
    window.addEventListener('pointercancel',onCancel,true);
  });
}
if(animMultiSelectEl){
  animMultiSelectEl.addEventListener('click',()=>{
    if(timelinePlaying) return;
    animMultiSelectMode=!animMultiSelectMode;
    if(!animMultiSelectMode){
      timelineSelected=new Set([timelineIndex]);
      timelineAnchor=timelineIndex;
    }else{
      if(timelineSelected.size===0) timelineSelected=new Set([timelineIndex]);
    }
    syncAnimUI();
  });
}
if(animNewFrameEl){
  animNewFrameEl.addEventListener('click',()=>{
    if(timelinePlaying) return;
    const cur=timeline[timelineIndex];
    const next=cur ? cloneTimelineFrame(cur) : { frames:[new Uint8Array(W*H),new Uint8Array(W*H),new Uint8Array(W*H),new Uint8Array(W*H)], delay:360 };
    timeline.splice(timelineIndex+1,0,next);
    timelineAnchor=timelineIndex+1;
    timelineSelected=new Set([timelineIndex+1]);
    setTimelineIndex(timelineIndex+1);
  });
}
if(animDeleteFrameEl){
  animDeleteFrameEl.addEventListener('click',()=>{
    if(timelinePlaying) return;
    if(timeline.length<=1) return;
    let toDelete=[...timelineSelected].filter(i=>i>=0 && i<timeline.length).sort((a,b)=>b-a);
    if(toDelete.length===0) toDelete=[timelineIndex];
    if(toDelete.length>=timeline.length){
      toDelete=toDelete.slice(0,timeline.length-1);
    }
    for(const i of toDelete){
      timeline.splice(i,1);
      const nextSelected=new Set();
      for(const s of timelineSelected){
        if(s===i) continue;
        nextSelected.add(s>i?s-1:s);
      }
      timelineSelected=nextSelected;
      if(timelineIndex===i) timelineIndex=Math.max(0,Math.min(timelineIndex,timeline.length-1));
      else if(timelineIndex>i) timelineIndex--;
    }
    if(timelineSelected.size===0) timelineSelected=new Set([timelineIndex]);
    timelineAnchor=timelineIndex;
    setTimelineIndex(timelineIndex);
  });
}
if(animDelayEl){
  animDelayEl.addEventListener('change',()=>{
    const v=Math.max(30,Number(animDelayEl.value)||0);
    const targets=[...timelineSelected].filter(i=>i>=0 && i<timeline.length);
    if(targets.length===0) targets.push(timelineIndex);
    for(const i of targets){
      const cur=timeline[i];
      if(cur) cur.delay=v;
    }
    syncAnimUI();
  });
}
if(animApplyAllDelayEl){
  animApplyAllDelayEl.addEventListener('click',()=>{
    const v=Math.max(30,Number(animDelayEl && animDelayEl.value)||0);
    if(!v) return;
    for(const cel of timeline){
      cel.delay=v;
    }
    syncAnimUI();
  });
}
function exportAnimGif(){
  const transparent=toggleTransparent && toggleTransparent.checked;
  const palette=[];
  for(let i=0;i<=MAX_COLOR_INDEX;i++) palette[i]=hexToRGB(colorMap[i] ?? '#000000');
  const gif=GIFEncoder({ repeat: 0 });
  for(const cel of timeline){
    let remaining=Math.max(30,cel.delay|0);
    while(remaining>0){
      for(let sub=0;sub<3 && remaining>0;sub++){
        const dt=Math.min(getJitterSubDelayMs(sub),remaining);
        const indicesRaw=cel.frames[sub];
        const indices=transparent ? indicesRaw : (()=>{ 
          const out=new Uint8Array(indicesRaw.length);
          for(let i=0;i<indicesRaw.length;i++){
            const v=indicesRaw[i];
            out[i]=v===0?1:v;
          }
          return out;
        })();
        const options={ palette, delay: dt };
        if(transparent) options.transparent=0;
        gif.writeFrame(indices,W,H,options);
        remaining-=dt;
      }
    }
  }
  gif.finish();
  const gifBytes=gif.bytes();
  const blob=new Blob([gifBytes],{type:'image/gif'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url;
  a.download='anim.gif';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
if(animExportGifEl){
  animExportGifEl.addEventListener('click',()=>{
    exportAnimGif();
  });
}
if(animPlayEl){
  animPlayEl.addEventListener('click',()=>{
    if(timelinePlaying) stopTimelinePlayback();
    else startTimelinePlayback();
  });
}
if(animPlayCloseEl){
  animPlayCloseEl.addEventListener('click',()=>{
    if(!timelinePlaying) startTimelinePlayback();
    closeAnim({ stopPlayback:false });
  });
}
function resampleMaskOR(src,sw,sh,ow,oh){
  const out=new Uint8Array(ow*oh);
  for(let y=0;y<oh;y++){
    const sy0=Math.floor(y*sh/oh);
    const sy1=Math.max(sy0+1,Math.floor((y+1)*sh/oh));
    for(let x=0;x<ow;x++){
      const sx0=Math.floor(x*sw/ow);
      const sx1=Math.max(sx0+1,Math.floor((x+1)*sw/ow));
      let on=0;
      for(let yy=sy0;yy<sy1 && !on;yy++){
        const row=yy*sw;
        for(let xx=sx0;xx<sx1;xx++){
          if(src[row+xx]){ on=1; break; }
        }
      }
      out[y*ow+x]=on;
    }
  }
  return out;
}
function trimMask(src,sw,sh){
  let minX=sw, minY=sh, maxX=-1, maxY=-1;
  for(let y=0;y<sh;y++){
    const row=y*sw;
    for(let x=0;x<sw;x++){
      if(!src[row+x]) continue;
      if(x<minX) minX=x;
      if(y<minY) minY=y;
      if(x>maxX) maxX=x;
      if(y>maxY) maxY=y;
    }
  }
  if(maxX<0) return { mask:new Uint8Array(1), w:1, h:1 };
  const w=maxX-minX+1;
  const h=maxY-minY+1;
  const out=new Uint8Array(w*h);
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      out[y*w+x]=src[(minY+y)*sw+(minX+x)];
    }
  }
  return { mask:out, w, h };
}
async function makeMask32FromImage(img){
  const maxDim=256;
  const scale=Math.min(1,maxDim/Math.max(img.width,img.height));
  const w=Math.max(1,Math.round(img.width*scale));
  const h=Math.max(1,Math.round(img.height*scale));
  const c=document.createElement('canvas');
  c.width=w;
  c.height=h;
  const cctx=c.getContext('2d');
  cctx.clearRect(0,0,w,h);
  cctx.drawImage(img,0,0,w,h);
  const data=cctx.getImageData(0,0,w,h).data;
  const mask=new Uint8Array(w*h);
  for(let i=0;i<mask.length;i++){
    const o=i*4;
    const a=data[o+3];
    if(a<128){ mask[i]=0; continue; }
    const r=data[o], g=data[o+1], b=data[o+2];
    const lum=(r*0.2126+g*0.7152+b*0.0722);
    mask[i]=lum<128?1:0;
  }
  const t=trimMask(mask,w,h);
  return resampleMaskOR(t.mask,t.w,t.h,PATTERN_W,PATTERN_H);
}
function renderPending(){
  patternEditEl.classList.toggle('is-visible',!!pendingMask32);
  if(!pendingMask32) return;
  patternPreviewCtx.clearRect(0,0,PATTERN_W,PATTERN_H);
  renderMaskToCanvas(pendingMask32,PATTERN_W,PATTERN_H,patternPreviewCtx);
}
patternUploadBtn.addEventListener('click',()=>{
  patternFileEl.value='';
  patternFileEl.click();
});
patternFileEl.addEventListener('change',async ()=>{
  const file=patternFileEl.files && patternFileEl.files[0];
  if(!file) return;
  try{
    const img=await fileToImage(file);
    pendingMask32=await makeMask32FromImage(img);
    renderPending();
  }catch{}
});
patternInvertBtn.addEventListener('click',()=>{
  if(!pendingMask32) return;
  for(let i=0;i<pendingMask32.length;i++) pendingMask32[i]=pendingMask32[i]?0:1;
  renderPending();
});
patternConfirmBtn.addEventListener('click',()=>{
  if(!pendingMask32) return;
  const id=`p${nextPatternId++}`;
  patterns.push({ id, mask: pendingMask32.slice() });
  activePatternId=id;
  pendingMask32=null;
  rebuildPatternList();
  renderPending();
});
function createPaletteButton(value){
  const btn=document.createElement('button');
  btn.type='button';
  btn.className='palette-btn';
  btn.dataset.value=String(value);
  btn.title=`笔${value}`;
  btn.innerHTML=`<span class="wrap"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a9 9 0 1 0 0 18c2.2 0 3-1 3-2.5S14 16 12.5 16H12a2 2 0 0 1 0-4h1.2c1.9 0 3.8-1.5 3.8-4.2A4.8 4.8 0 0 0 12 3Z"/><path d="M7.5 10.5h.01"/><path d="M9.5 7.5h.01"/><path d="M14.5 7.5h.01"/><path d="M16.5 10.5h.01"/></svg><span class="swatch"></span></span>`;
  btn.addEventListener('click',()=>{
    paletteValue=value;
    setTool('palette');
  });
  return btn;
}
const paletteButtons=[];
for(let i=1;i<=BASE_COLOR_COUNT;i++){
  const btn=createPaletteButton(i);
  paletteButtons.push(btn);
  paletteToolsEl.appendChild(btn);
}
function syncPaletteButtonsColors(){
  for(const btn of paletteButtons){
    const v=Number(btn.dataset.value);
    const swatch=btn.querySelector('.swatch');
    if(swatch) swatch.style.background=colorMap[v] ?? '#000000';
  }
}
function syncPaletteButtonsActive(){
  for(const btn of paletteButtons){
    const v=Number(btn.dataset.value);
    btn.classList.toggle('is-active',currentTool==='palette' && v===paletteValue);
  }
}
function applyBackground(){
  // “透明背景”开关只影响棋盘格的显示，用于表达透明区域
  const bg1=colorMap[1];
  if(containerEl) containerEl.style.background='#fff';
  const showBgLayer=toggleTransparent.checked;
  checkerboard.style.display='block';
  if(customBgUrl){
    checkerboard.style.backgroundImage=`url("${customBgUrl}")`;
    checkerboard.style.backgroundSize='contain';
    checkerboard.style.backgroundRepeat='no-repeat';
    checkerboard.style.backgroundPosition='center';
  }else{
    checkerboard.style.backgroundImage=
      `linear-gradient(45deg, #dcdcdc 25%, transparent 25%, transparent 75%, #dcdcdc 75%, #dcdcdc),
       linear-gradient(45deg, ${bg1} 25%, transparent 25%, transparent 75%, ${bg1} 75%, ${bg1})`;
    checkerboard.style.backgroundSize='16px 16px';
    checkerboard.style.backgroundPosition='0 0, 8px 8px';
    checkerboard.style.backgroundRepeat='repeat';
  }
  updateCheckerboardScale();
  if(canvasBgEl){
    canvasBgEl.style.display=showBgLayer?'none':'block';
    canvasBgEl.style.background=bg1;
  }
  const previewBg=document.getElementById('previewBg');
  if(showBgLayer){
    if(customBgUrl){
      previewBg.style.backgroundImage=`url("${customBgUrl}")`;
      previewBg.style.backgroundSize='contain';
      previewBg.style.backgroundRepeat='no-repeat';
      previewBg.style.backgroundPosition='center';
      previewBg.style.backgroundColor=bg1;
    }else{
      previewBg.style.backgroundImage=
        `linear-gradient(45deg, #dcdcdc 25%, transparent 25%, transparent 75%, #dcdcdc 75%, #dcdcdc),
         linear-gradient(45deg, ${bg1} 25%, transparent 25%, transparent 75%, ${bg1} 75%, ${bg1})`;
      previewBg.style.backgroundSize='16px 16px';
      previewBg.style.backgroundPosition='0 0, 8px 8px';
      previewBg.style.backgroundColor='';
    }
  }else{
    previewBg.style.backgroundImage='none';
    previewBg.style.backgroundColor=bg1;
  }
}
toggleTransparent.addEventListener('change',()=>{
  applyBackground();
  renderCurrent();
});
applyBackground();
syncOutlineColorsUI();
syncPaletteButtonsColors();
syncHistoryUI();
rebuildPatternList();
renderPending();
applyPlaybackMode();
setTool('pencil');

function nearestPaletteIndex(r,g,b,paletteRGB){
  let bestI=1;
  let bestD=Infinity;
  for(let i=1;i<=BASE_COLOR_COUNT;i++){
    const pr=paletteRGB[i][0], pg=paletteRGB[i][1], pb=paletteRGB[i][2];
    const dr=r-pr, dg=g-pg, db=b-pb;
    const d=dr*dr+dg*dg+db*db;
    if(d<bestD){ bestD=d; bestI=i; }
  }
  return bestI;
}
function compositeFrame(screenW,screenH,composite){
  const paletteRGB=Array.from({length: BASE_COLOR_COUNT+1},(_,i)=>i?hexToRGB(colorMap[i]):[0,0,0]);
  const out=new Uint8Array(W*H);
  for(let y=0;y<H;y++){
    const sy=Math.floor(y*screenH/H);
    for(let x=0;x<W;x++){
      const sx=Math.floor(x*screenW/W);
      const o=(sy*screenW+sx)*4;
      const a=composite[o+3];
      if(a<128){
        out[y*W+x]=0;
      }else{
        const r=composite[o], g=composite[o+1], b=composite[o+2];
        out[y*W+x]=nearestPaletteIndex(r,g,b,paletteRGB);
      }
    }
  }
  return out;
}
async function importGifFromFile(file){
  const buf=await file.arrayBuffer();
  const gif=parseGIF(new Uint8Array(buf));
  const screenW=gif.lsd?.width ?? W;
  const screenH=gif.lsd?.height ?? H;
  const decoded=decompressFrames(gif,true);
  if(!decoded || decoded.length===0) return;
  const composite=new Uint8ClampedArray(screenW*screenH*4);
  const mapped=[];
  let restore=null;
  for(const f of decoded){
    const { left=0, top=0, width=screenW, height=screenH }=f.dims ?? {};
    const patch=f.patch;
    if(f.disposalType===3){
      restore=composite.slice();
    }else{
      restore=null;
    }
    if(patch && width>0 && height>0){
      for(let y=0;y<height;y++){
        const dy=top+y;
        if(dy<0||dy>=screenH) continue;
        for(let x=0;x<width;x++){
          const dx=left+x;
          if(dx<0||dx>=screenW) continue;
          const so=(y*width+x)*4;
          const a=patch[so+3];
          if(a===0) continue;
          const to=(dy*screenW+dx)*4;
          composite[to]=patch[so];
          composite[to+1]=patch[so+1];
          composite[to+2]=patch[so+2];
          composite[to+3]=a;
        }
      }
    }
    mapped.push(compositeFrame(screenW,screenH,composite));
    if(f.disposalType===2 && width>0 && height>0){
      for(let y=0;y<height;y++){
        const dy=top+y;
        if(dy<0||dy>=screenH) continue;
        for(let x=0;x<width;x++){
          const dx=left+x;
          if(dx<0||dx>=screenW) continue;
          const to=(dy*screenW+dx)*4;
          composite[to]=0; composite[to+1]=0; composite[to+2]=0; composite[to+3]=0;
        }
      }
    }else if(f.disposalType===3 && restore){
      composite.set(restore);
    }
  }
  const srcCount=mapped.length;
  for(let fi=0;fi<3;fi++){
    frames[fi].set(mapped[fi%srcCount]);
  }
  frames[3].set(mapped[0]);
}
importGifBtn.addEventListener('click',()=>{
  gifFileEl.value='';
  gifFileEl.click();
});
gifFileEl.addEventListener('change',async ()=>{
  const file=gifFileEl.files && gifFileEl.files[0];
  if(!file) return;
  stopAnim();
  try{
    await importGifFromFile(file);
  }catch{}
  if(jitterOnEl.checked){
    displayFrame=0;
    startAnim();
  }else{
    displayFrame=3;
  }
  renderCurrent();
});
importBgBtn.addEventListener('click',()=>{
  bgFileEl.value='';
  bgFileEl.click();
});
bgFileEl.addEventListener('change',()=>{
  const file=bgFileEl.files && bgFileEl.files[0];
  if(!file) return;
  if(customBgUrl) URL.revokeObjectURL(customBgUrl);
  customBgUrl=URL.createObjectURL(file);
  applyBackground();
  renderCurrent();
});
</script>
</body>
</html>
